<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="what&#39;s you problem">
<meta property="og:type" content="website">
<meta property="og:title" content="yezh&#39;s blog">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="yezh&#39;s blog">
<meta property="og:description" content="what&#39;s you problem">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="yezh">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false
  };
</script>

  <title>yezh's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">yezh's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">菜鸟当家</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section">首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section">关于</a>

  </li>
        <li class="menu-item menu-item-标签">

    <a href="/tags/" rel="section">标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section">分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section">归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/28/namespace%E5%AE%9E%E9%AA%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yezh">
      <meta itemprop="description" content="what's you problem">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yezh's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/07/28/namespace%E5%AE%9E%E9%AA%8C/" class="post-title-link" itemprop="url">namespace实验</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-07-28 14:05:03" itemprop="dateCreated datePublished" datetime="2019-07-28T14:05:03+08:00">2019-07-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-13 17:26:07" itemprop="dateModified" datetime="2020-03-13T17:26:07+08:00">2020-03-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Net-namespace实验"><a href="#Net-namespace实验" class="headerlink" title="Net namespace实验"></a>Net namespace实验</h1><p>  在 Linux 中，网络名字空间可以被认为是隔离的拥有单独网络栈（网卡、路由转发表、iptables）的环境。网络名字空间经常用来隔离网络设备和服务，只有拥有同样网络名字空间的设备，才能看到彼此。 network namespace 是实现网络虚拟化的重要功能，它能创建多个隔离的网络空间，它们有独自的网络栈信息。不管是虚拟机还是容器，运行的时候仿佛自己就在独立的网络中</p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><table>
<thead>
<tr>
<th align="left">comm</th>
<th align="left">命令</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ip netns add  net1</td>
<td align="left">添加namespace net1</td>
</tr>
<tr>
<td align="left">ip netns help</td>
<td align="left">获取帮助</td>
</tr>
<tr>
<td align="left">ip netns del n1</td>
<td align="left">删除namespace n1</td>
</tr>
<tr>
<td align="left">ip netns ls</td>
<td align="left">列出当前已有namespace</td>
</tr>
<tr>
<td align="left">与net namespace相关的指令是<code>ip netns</code>后面跟具体指令</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">使用<code>ip netns exec   name</code>子命令后面可以加上任何命令，表示在相应的namespace中执行相关命令，如：</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@mininet-vm:/home/mininet<span class="comment"># ip netns exec n2 ip addr</span></span><br><span class="line">1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN group default </span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br></pre></td></tr></table></figure></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">可以执行<code>ip netns exec n2 bash</code>，之后所有指令都在指定namespace中执行而不需要加上<code>ip netns exec   name</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">root@mininet-vm:/home/mininet<span class="comment"># ip netns exec n2 ip addr</span></span><br><span class="line">1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN group default </span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">root@mininet-vm:/home/mininet<span class="comment"># ip netns exec n2 bash</span></span><br><span class="line">root@mininet-vm:/home/mininet<span class="comment"># ip addr</span></span><br><span class="line">1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN group default </span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">root@mininet-vm:/home/mininet<span class="comment"># exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">root@mininet-vm:/home/mininet<span class="comment"># ip addr</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default </span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast </span><br><span class="line">.................</span><br></pre></td></tr></table></figure></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">使用<code>ip netns exec n2 bash  --rcfile &lt;(echo &quot;PS1=\&quot;namespace ns1&gt;\&quot;&quot;)</code>可以修改命令行的前缀。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@mininet-vm:/home/mininet<span class="comment"># ip netns exec n2 bash --rcfile &lt;(echo "PS1=\"namespace n2&gt;\"")</span></span><br><span class="line">namespace n2&gt;</span><br></pre></td></tr></table></figure></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">##　namespace通信</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">### 使用 veth pair 进行通信</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">1. 创建一对veth pair</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">使用命令<code>ip link add type veth</code>创建一对veth pair，其默认名是veth0和veth1，使用<code>ip link</code>可查看链接</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   root@mininet-vm:/home/mininet<span class="comment"># ip link</span></span><br><span class="line">.....</span><br><span class="line">3: ovs-system: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN </span><br><span class="line">root@mininet-vm:/home/mininet <span class="comment"># ip link add type veth</span></span><br><span class="line">root@mininet-vm:/home/mininet <span class="comment"># ip link</span></span><br><span class="line">....</span><br><span class="line">3: ovs-system: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN </span><br><span class="line">9: veth0@veth1: &lt;BROADCAST,MULTICAST,M-DOWN&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether 12:e8:a5:43:c0:43 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">10: veth1@veth0: &lt;BROADCAST,MULTICAST,M-DOWN&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether 9e:f8:c3:b9:af:ec brd ff:ff:ff:ff:ff:ff</span><br></pre></td></tr></table></figure></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">2. 将veth pair的两端分别放到两个namespace</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">使用命令<code>ip link set veth0 netns n1</code>和<code>ip link set veth1 netns n2</code>分别将veth0和veth1放到不同namespace</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">oot@mininet-vm:/home/mininet<span class="comment"># ip link set veth0 netns n1</span></span><br><span class="line">root@mininet-vm:/home/mininet<span class="comment"># ip link set veth1 netns n2</span></span><br><span class="line">root@mininet-vm:/home/mininet<span class="comment"># ip netns exec n1 ip addr</span></span><br><span class="line">1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN group default </span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">9: veth0@if10: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN group default qlen 1000</span><br><span class="line">    link/ether 12:e8:a5:43:c0:43 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">root@mininet-vm:/home/mininet<span class="comment"># ip netns exec n2 ip addr</span></span><br><span class="line">1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN group default </span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">10: veth1@if9: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN group default qlen 1000</span><br><span class="line">    link/ether 9e:f8:c3:b9:af:ec brd ff:ff:ff:ff:ff:ff</span><br></pre></td></tr></table></figure></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">3. 为veth pair的两端分别配置ip</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">使用命令<code>ip link set vethX up</code>和<code>ip addr add  10.0.0.10/24 dev vethX</code>为veth pair配置ip，结果如下</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># namespace 1</span></span><br><span class="line">namespace ns1&gt; ip link <span class="built_in">set</span> veth0 up</span><br><span class="line">namespace ns1&gt; ip a</span><br><span class="line">1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN group default </span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">9: veth0@if10: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000</span><br><span class="line">    link/ether 12:e8:a5:43:c0:43 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">namespace ns1&gt; ip addr add 10.0.10.1/24 dev veth0</span><br><span class="line">namespace ns1&gt; ip a</span><br><span class="line">1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN group default </span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">9: veth0@if10: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000</span><br><span class="line">    link/ether 12:e8:a5:43:c0:43 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 10.0.10.x1/24 scope global veth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"></span><br><span class="line"><span class="comment"># namespace 2</span></span><br><span class="line">namespace n2&gt;ip link <span class="built_in">set</span> veth1 up</span><br><span class="line">namespace n2&gt;ip addr add 10.0.10/24 dev veth1</span><br><span class="line">namespace n2&gt;ip a</span><br><span class="line">1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN group default </span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">10: veth1@if9: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc pfifo_fast state LOWERLAYERDOWN group default qlen 1000</span><br><span class="line">link/ether 9e:f8:c3:b9:af:ec brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 10.0.10.0/24 scope global veth1</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">4. 测试两个namespace之间的网络联通状态</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">分别在n1和n2中尝试ping</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">namespace ns1&gt; ping 10.0.10.0 -c 1</span><br><span class="line">PING 10.0.10.0 (10.0.10.0) 56(84) bytes of data.</span><br><span class="line">64 bytes from 10.0.10.0: icmp_seq=1 ttl=64 time=0.035 ms</span><br><span class="line">namespace n2&gt;ping 10.0.10.1 -c 1</span><br><span class="line">PING 10.0.10.1 (10.0.10.1) 56(84) bytes of data.</span><br><span class="line">64 bytes from 10.0.10.1: icmp_seq=1 ttl=64 time=0.040 ms</span><br></pre></td></tr></table></figure></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">5. 其拓扑结构如下</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><img src="https://raw.githubusercontent.com/zdzh/pothos/master/img/20190725185608.png" alt="20190725185608.png"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><em>veth pair可以用于两个namespace之间的通信，但不适合用在多个namespace之间的通行</em></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">### 利用bridge通信</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">1. 在以上实验基础上，重新创建两个namespace：n3、n4</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@mininet-vm:/home/mininet<span class="comment"># ip netns add n3</span></span><br><span class="line">root@mininet-vm:/home/mininet<span class="comment"># ip netns add n4</span></span><br><span class="line">root@mininet-vm:/home/mininet<span class="comment"># ip netns ls</span></span><br><span class="line">n4</span><br><span class="line">n3</span><br><span class="line">n1</span><br><span class="line">n2</span><br></pre></td></tr></table></figure></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">2. 创建bridge</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">root@mininet-vm:/home/mininet<span class="comment"># ip link add br0 type bridge</span></span><br><span class="line">root@mininet-vm:/home/mininet<span class="comment"># ip a</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default </span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000</span><br><span class="line">    link/ether 00:0c:29:1e:27:79 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.117.128/24 brd 192.168.117.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">3: ovs-system: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN group default </span><br><span class="line">    link/ether 72:f5:e5:5d:4d:ed brd ff:ff:ff:ff:ff:ff</span><br><span class="line">11: br0: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN group default </span><br><span class="line">    link/ether 76:d8:06:1a:b9:84 brd ff:ff:ff:ff:ff:ff</span><br></pre></td></tr></table></figure></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">3. 利用veth pair将bridge与n3、n4、n1连通</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">创建3对veth pair</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">root@mininet-vm:/home/mininet<span class="comment"># ip link add type veth</span></span><br><span class="line">root@mininet-vm:/home/mininet<span class="comment"># ip link add type veth</span></span><br><span class="line">root@mininet-vm:/home/mininet<span class="comment"># ip link add type veth</span></span><br><span class="line">root@mininet-vm:/home/mininet<span class="comment"># ip a</span></span><br><span class="line">...</span><br><span class="line">11: br0: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN group default </span><br><span class="line">    link/ether 76:d8:06:1a:b9:84 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">12: veth0@veth1: &lt;BROADCAST,MULTICAST,M-DOWN&gt; mtu 1500 qdisc noop state DOWN group default qlen 1000</span><br><span class="line">    link/ether ea:98:b6:3c:46:60 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">13: veth1@veth0: &lt;BROADCAST,MULTICAST,M-DOWN&gt; mtu 1500 qdisc noop state DOWN group default qlen 1000</span><br><span class="line">    link/ether f2:f6:d8:6b:31:1f brd ff:ff:ff:ff:ff:ff</span><br><span class="line">14: veth2@veth3: &lt;BROADCAST,MULTICAST,M-DOWN&gt; mtu 1500 qdisc noop state DOWN group default qlen 1000</span><br><span class="line">    link/ether 4a:7d:af:18:67:14 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">15: veth3@veth2: &lt;BROADCAST,MULTICAST,M-DOWN&gt; mtu 1500 qdisc noop state DOWN group default qlen 1000</span><br><span class="line">    link/ether ca:b6:e4:eb:b7:15 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">16: veth4@veth5: &lt;BROADCAST,MULTICAST,M-DOWN&gt; mtu 1500 qdisc noop state DOWN group default qlen 1000</span><br><span class="line">    link/ether f2:b3:5f:0e:3d:09 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">17: veth5@veth4: &lt;BROADCAST,MULTICAST,M-DOWN&gt; mtu 1500 qdisc noop state DOWN group default qlen 1000</span><br><span class="line">    link/ether 76:0c:87:b1:16:80 brd ff:ff:ff:ff:ff:ff</span><br></pre></td></tr></table></figure></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">将br0和n1，n3，n4连接</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">这时候如果把veth0加入n1的话会报错，因为n1里面已经有了一个veth0，可以换成其他名称的veth。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">将veth pair放如br0的指令为<code>ip link set dev veth3 master br0</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">4. 测试n1-n4之间的连通状态</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">发现不同namespace之间无法ping通 。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">这个问题折腾了很久，后来多配置了几次有可以了。应该是之前漏掉了几个步骤，完整的步骤应该包括以下几步：</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment"># 启动网桥（网桥只需要启动一次就行）</span></span><br><span class="line"> ip link <span class="built_in">set</span> br0 up</span><br><span class="line"> <span class="comment"># 创建vethpair</span></span><br><span class="line"> ip link add br-1 <span class="built_in">type</span> veth peer name 1-br</span><br><span class="line"> <span class="comment">#将vethpair分配给网桥和namespace</span></span><br><span class="line"> ip link <span class="built_in">set</span> br-1 master br0</span><br><span class="line"> ip link <span class="built_in">set</span> 1-br netns n1</span><br><span class="line"> <span class="comment">#启动veth</span></span><br><span class="line"> ip link <span class="built_in">set</span> br-1 up</span><br><span class="line"> ip netns <span class="built_in">exec</span> n1 ip link <span class="built_in">set</span> 1-br up</span><br><span class="line"> <span class="comment"># 为namespace中的veth设置ip</span></span><br><span class="line">ip netns <span class="built_in">exec</span> n1 ip addr add 10.0.10.2/24 dev 1-br</span><br></pre></td></tr></table></figure></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">重新测试，发现三个namespace可以相互ping通。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><em>上述网桥对应的veth的ip其实可以省略</em></td>
<td align="left"></td>
</tr>
</tbody></table>
<ol start="5">
<li>其拓扑结构如下<br><img src="https://raw.githubusercontent.com/zdzh/pothos/master/img/!%5B20190726101019.png%5D(httpsraw.githubusercontent.comzdzhpothosmasterimg20190726101019.png)" alt=""></li>
</ol>
<h3 id="namespace内部与namespace外部通信"><a href="#namespace内部与namespace外部通信" class="headerlink" title="namespace内部与namespace外部通信"></a>namespace内部与namespace外部通信</h3><p>默认情况下，namespace网络是隔离的，namespace内无法ping通namespace外的网络，可以通过veth pair打通网络状态。<br>当veth pair一端在namespace内部，一端在namespace外部时，namespace可以ping通位于外部的veth pair但无法ping同其他网络。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<p><a href="https://cizixs.com/2017/02/10/network-virtualization-network-namespace/" target="_blank" rel="noopener">https://cizixs.com/2017/02/10/network-virtualization-network-namespace/</a></p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/28/mininet-vxla%E5%AE%9E%E9%AA%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yezh">
      <meta itemprop="description" content="what's you problem">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yezh's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/07/28/mininet-vxla%E5%AE%9E%E9%AA%8C/" class="post-title-link" itemprop="url">mininet:vxla实验</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-07-28 14:01:46" itemprop="dateCreated datePublished" datetime="2019-07-28T14:01:46+08:00">2019-07-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-13 17:26:07" itemprop="dateModified" datetime="2020-03-13T17:26:07+08:00">2020-03-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="mininet：vxlan实验"><a href="#mininet：vxlan实验" class="headerlink" title="mininet：vxlan实验"></a>mininet：vxlan实验</h1><h2 id="需改虚拟机的网络适配器，将其改为host-only"><a href="#需改虚拟机的网络适配器，将其改为host-only" class="headerlink" title="需改虚拟机的网络适配器，将其改为host-only"></a>需改虚拟机的网络适配器，将其改为host-only</h2><p> 尝试ping宿主机ip地址，此时能够ping同与虚拟机相连的虚拟网卡ip地址，无法ping同其他网卡ip地址</p>
<h2 id="在虚拟机和宿主机中创建网络topo"><a href="#在虚拟机和宿主机中创建网络topo" class="headerlink" title="在虚拟机和宿主机中创建网络topo"></a>在虚拟机和宿主机中创建网络topo</h2><h3 id="在虚拟机运行以下指令创建topo"><a href="#在虚拟机运行以下指令创建topo" class="headerlink" title="在虚拟机运行以下指令创建topo"></a>在虚拟机运行以下指令创建topo</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo  mn</span><br></pre></td></tr></table></figure>

<p>此时，在虚拟机中含以下网络节点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hosts:  h1 h2 </span><br><span class="line">switches: s1 </span><br><span class="line">links: (h1, s1) (h2, s1) </span><br><span class="line">controller：c0</span><br></pre></td></tr></table></figure>

<p>其中h1和h2的ip分别为<code>10.0.0.1</code>和<code>10.0.0.2</code></p>
<h3 id="在宿主机中创建topo网络"><a href="#在宿主机中创建topo网络" class="headerlink" title="在宿主机中创建topo网络"></a>在宿主机中创建topo网络</h3><p>新建topo-2sw-2host.py</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mininet.topo <span class="keyword">import</span> Topo</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTopo</span><span class="params">( Topo )</span>:</span></span><br><span class="line">    <span class="string">"Simple topology example."</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build</span><span class="params">( self )</span>:</span></span><br><span class="line">        <span class="string">"Create custom topo."</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Add hosts and switches</span></span><br><span class="line">        h3 = self.addHost( <span class="string">'h3'</span>,ip=<span class="string">'10.0.0.3'</span> )</span><br><span class="line">        h4 = self.addHost( <span class="string">'h4'</span>,ip=<span class="string">'10.0.0.4'</span> )</span><br><span class="line">        leftSwitch = self.addSwitch( <span class="string">'s3'</span> )</span><br><span class="line">        <span class="comment"># Add links</span></span><br><span class="line">        self.addLink( h3, leftSwitch )</span><br><span class="line">        self.addLink( leftSwitch,h4)</span><br><span class="line">topos = &#123; <span class="string">'mytopo'</span>: ( <span class="keyword">lambda</span>: MyTopo() ) &#125;</span><br></pre></td></tr></table></figure>
<p>通过命令<code>sudo mn --custom topo-2sw-2host.py --topo mytopo</code>创建网络topo<br>其中h1和h2的ip分别为<code>10.0.0.3</code>和<code>10.0.0.4</code></p>
<h2 id="关闭控制器"><a href="#关闭控制器" class="headerlink" title="关闭控制器"></a>关闭控制器</h2><blockquote>
<p>控制器能够帮助switch建立流表，如果要手动建立nodes链接关系，需要先关闭控制器。</p>
</blockquote>
<p><em>注意：也可以在mn命令的最后添加 <code>--controller remote</code>关闭controller，以省略以下步骤</em><br>在关闭控制器前测试h1与h2之间互ping，因为controller的存在，彼此能够ping通。<br>在宿主机和虚拟机中分别输入<code>sudo killall controller</code>关闭控制器，这时候再尝试ping，发现无法ping通。因为switch中流表为空。<br>执行<code>sh ovs-ofctl dump-flows s1</code>,可以看到流表为空，其信息如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mininet&gt; sh ovs-ofctl dump-flows s1</span><br><span class="line">NXST_FLOW reply (xid=0x4):</span><br></pre></td></tr></table></figure>
<h2 id="创建vxlan"><a href="#创建vxlan" class="headerlink" title="创建vxlan"></a>创建vxlan</h2><p>运行<code>sh ovs-vsctl add-port s1 vxlan</code>添加vxlan端口。<br>在虚拟机中，端口可以成功成功创建，但在宿主机中创建失败，提示错误信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mininet&gt; sh ovs-vsctl add-port s13vxlan</span><br><span class="line">ovs-vsctl: Error detected while setting up &#39;vxlan&#39;: could not open network device vxlan (No such device).  See ovs-vswitchd log for details.</span><br><span class="line">ovs-vsctl: The default log directory is &quot;&#x2F;var&#x2F;log&#x2F;openvswitch&quot;.</span><br></pre></td></tr></table></figure>
<p>解决方案如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">The port‘s name should be a exist interface use ifconfig to see, such as eth0. If you just want to use a virtual port name to make a test you should </span><br><span class="line">specify the port&#39;s type like ovs-vsctl add-port br0 port0 -- set Interface port0 type&#x3D;internal or ovs-vsctl set Interface port0 type&#x3D;internal</span><br></pre></td></tr></table></figure>
<p>将指令改为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh ovs-vsctl add-port s3 vxlan   -- set Interface vxlan type&#x3D;internal</span><br></pre></td></tr></table></figure>
<p>在虚拟机中输入以下指令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh ovs-vsctl set interface vxlan type&#x3D;vxlan option:remote_ip&#x3D;10.0.0.7 option:key&#x3D;100 ofport_request&#x3D;10</span><br></pre></td></tr></table></figure>
<p>其中 ip地址是宿主机的ip，key是vxlan的标签，opport_request是端口名称<br>在宿主机中需要将以上命令的ip改为虚拟机的ip地址。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上建立的网络形式如下<br><img src="https://raw.githubusercontent.com/zdzh/pothos/master/img/20190725110710.png" alt="20190725110710.png"><br>其中R为路由器，s1和s2为交换机，h1-h4为主机</p>
<h3 id="同一交换机下的主机通信"><a href="#同一交换机下的主机通信" class="headerlink" title="同一交换机下的主机通信"></a>同一交换机下的主机通信</h3><p><img src="https://raw.githubusercontent.com/zdzh/pothos/master/img/20190725113623.png" alt="20190725113623.png"></p>
<ol>
<li>h1尝试ping h2时，拥有h2的ip地址但没有h2的mac地址。因此h1首先尝试通过arp获取h2  mac地址。</li>
<li>h1  发送 arp给 s1，s1收到arp后进行广播，同时记录h1的mac地址和端口的映射。h2收到广播后发现与自己的ip一致，根据广播给定的ip地址向s1发送响应，s1将响应发送给h1，同时s1记录h2的mac地址和端口的映射。</li>
<li>h1获取h2的mac地址后，在包里面加入h2的ip地址和mac地址并发送给s1.</li>
<li>s1收到包后，检查mac地址，找出对应的h2端口映射，将包发送到h2对应的端口</li>
<li>h2收到包后，匹配包的ip地址，ip地址一致则对包做进一步处理</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/28/ARP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yezh">
      <meta itemprop="description" content="what's you problem">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yezh's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/07/28/ARP/" class="post-title-link" itemprop="url">ARP</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-07-28 13:59:23" itemprop="dateCreated datePublished" datetime="2019-07-28T13:59:23+08:00">2019-07-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-13 17:26:07" itemprop="dateModified" datetime="2020-03-13T17:26:07+08:00">2020-03-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="地址解析协议（ARP）"><a href="#地址解析协议（ARP）" class="headerlink" title="地址解析协议（ARP）"></a>地址解析协议（ARP）</h1><p>地址解析协议（ARP）是指网络地址和MAC地址之间的转换<br>当一台主机需要向另一台主机发送数据时，需要知道目的主机的ip地址外还需要知道目的主机的mac地址。源主机首先会在自己的ARP表中寻找目的ip对应的mac地址，无法找到则发出一个arp广播包，目的主机收到广播包后发送一个响应报文告知源主机自己的mac地址。</p>
<h2 id="交换机对包的处理："><a href="#交换机对包的处理：" class="headerlink" title="交换机对包的处理："></a>交换机对包的处理：</h2><p>当交换机收到包时，会查找交换机表，其可能遇到三种情况：</p>
<ol>
<li>未找到相应记录，广播该包，将该包发送给除源端口外的所有端口</li>
<li>找到相应记录，且对应端口与源端口不同，将该包转发给相应端口</li>
<li>找到相应端口，但相应端口与源端口相同，将该包丢弃<h2 id="路由器对ARP的处理"><a href="#路由器对ARP的处理" class="headerlink" title="路由器对ARP的处理"></a>路由器对ARP的处理</h2>路由器会阻断包括ARP在内的广播包，也就是说主机无法通过以上的方式获取目的主机的mac地址。<br>当两台主机位于不同子网或网段时，主机之间无法通过交换机通信，这个时候必须借助网关或者路由器。当主机发现访问的主机位于不同网段时，主机会将包发送给路由器，在通过路由器转发该包。<br><img src="https://raw.githubusercontent.com/zdzh/pothos/master/img/20190725162055.png" alt="20190725162055.png"><br>上图中，H1主机发送数据包给H2，在传输过程中，目的ip始终为h2的ip，但目的mac地址是下一跳的mac地址。<br>需要注意的是，图中没有注明每个路由器的ip地址，而在实际网络中，路由器内含有一个交换表注明目的ip与下一跳ip的映射，路由器底层将下一跳的ip进行转化以获取下一跳的mac地址。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/neutron/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yezh">
      <meta itemprop="description" content="what's you problem">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yezh's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/neutron/" class="post-title-link" itemprop="url">neutron</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-07-22 09:35:04" itemprop="dateCreated datePublished" datetime="2019-07-22T09:35:04+08:00">2019-07-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-13 17:26:07" itemprop="dateModified" datetime="2020-03-13T17:26:07+08:00">2020-03-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/openSwitch/" itemprop="url" rel="index"><span itemprop="name">openSwitch</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>neutron的作用是实现虚拟机之间的网络通信及其管理功能，其中，虚拟机可是位于多台服务器，也可以在一台服务器上，虚拟机之间可以划分LAN，同一LAN下的虚拟机可以相互通信，不同LAN的虚拟机之间是不可见的，同一LAN的虚拟机可以位于不同的服务器。Neutron 实现了基于物理 VLAN 交换机的跨物理服务器二层虚拟网络。在同一服务器下的相同LAN虚拟机通过虚拟网桥或交换机进行通信，不同服务器之间的虚拟机通过物理交换机通信。  </p>
<h2 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h2><p>NAT(Network Address Transorm)网络地址转换协议，用于内网和外网之间的地址转换。</p>
<p>SNAT(Source Network Address Transform)源网络地址转化。当内部地址需要访问外部服务时，内部地址会主动发起链接，由路由器或者网关对内部地址做源地址转化</p>
<p>DNAT(Destination Network Address Transform)目的地址转化。当外部网络需要访问内部服务时，由路由器或者网关接受外部链接，然后将外部链接转化为内部链接</p>
<h2 id="网络拓扑结构"><a href="#网络拓扑结构" class="headerlink" title="网络拓扑结构"></a>网络拓扑结构</h2><p>在典型的网络生产环境中，一般将网络分为一下4种：</p>
<ol>
<li>公共网络，即外网网络</li>
<li>管理网络，即OpenStack自身组件使用的网络</li>
<li>服务网络，即虚拟机所使用的内网网络</li>
<li>存储网络，存储专用网络，一般和管理网络同网段。</li>
</ol>
<p>Neutron支持一下5种网络拓扑结构</p>
<ol>
<li>单一平面网络是指所有租户共享一个相同的服务网络和公共网络，意味着一个租户下的虚拟机能够访问其他租户下的虚拟机，隔离性不好。</li>
<li>多平面网络也是服务网络和公共网络相同，但是可以有多个共享网络，当两个虚拟机需要通信时，虚拟机内部可以通过多网卡同时共享一个网段，这些共享网段对所有租户共享。</li>
<li>混合平面私有网络是指每个租户拥有自己的服务网络同时共享相同的公共网络。</li>
<li>通过私有网络实现运营商路由功能，是指每个租户拥有自己的服务网络，并且虚拟机可以直接通过提供商路由所提供的SNAT功能访问外部网络命名空间</li>
<li>通过私有网络实现每个租户创建自己专属的网络专区，支持命名空间，每个网络可以选择拥有自己独立的提供商路由——一般来说是虚拟路由</li>
</ol>
<h2 id="VLAN"><a href="#VLAN" class="headerlink" title="VLAN"></a>VLAN</h2><p>VLAN 表示 Virutal LAN。一个带有 VLAN 功能的switch 能够同时处于多个 LAN 中。最简单地说，VLAN 是一种将一个交换机分成多个交换机的一种方法。比方说，你有两组机器，group A 和 B，你想配置成组 A 中的机器可以相互访问，B 中的机器也可以相互访问，但是A组中的机器不能访问B组中的机器。你可以使用两个交换机，两个组分别接到一个交换机。如果你只有一个交换机，你可以使用 VLAN 达到同样的效果。你在交换机上分配配置连接组A和B的机器的端口为 VLAN access ports。这个交换机就会只在同一个 VLAN 的端口之间转发包。</p>
<p> 以太网端口有三种链路类型：Access、Hybrid和Trunk。</p>
<ul>
<li>Access类型的端口只能属于1个VLAN，一般用于连接计算机的端口。这种类型的端口允许接收没有打标签的帧，再发出去时将会被打上标签。</li>
<li>Trunk类型的端口可以属于多个VLAN，可以接收和发送多个VLAN的报文，一般用于交换机之间连接的端口</li>
<li>Hybrid类型的端口可以属于多个VLAN，可以接收和发送多个VLAN的报文，可以用于交换机之间连接，也可以用于连接用户的计算机。Hybrid端口和Trunk端口的不同之处在于Hybrid端口可以允许多个VLAN的报文发送时不打标签，而Trunk端口只允许缺省VLAN的报文发送时不打标签。</li>
</ul>
<p>标签是为了方便交换机识别传输的数据属于哪个LAN，对于计算机来说，其只接受其所在的LAN的数据帧，而筛选帧的过程是由交换机完成的。由于帧所属LAN的判断是由交换机完成而非计算机，因此，用于与计算机相连的Acess中的帧不含标签，而用于交换机与交换机之间的Trunk必须包含的标签。</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><table>
<thead>
<tr>
<th>valn</th>
<th>虚拟lan,同一个物理lan下用标签实现隔离</th>
</tr>
</thead>
<tbody><tr>
<td>vxlan</td>
<td>一套利用UDP协议作为底层传输协议的Overlay实现。一般认为作为VLan技术的延申或替代者。</td>
</tr>
<tr>
<td>gre</td>
<td>一种通过封装来实现隧道的方式。在openstack中一般是基于L3的gre</td>
</tr>
<tr>
<td>TAP设备</td>
<td>比如vnet0，是虚拟化技术如KVM和Xen用来实现虚拟网卡的。当一个以太网帧发送给TAP设备时，该帧会被虚拟机操作系统所接收。</td>
</tr>
<tr>
<td>VETH pair</td>
<td>veth配对设备或OVS配对端口（patch port），是一对一直相连的虚拟网络接口。在虚拟网络技术中，经常使用veth pair作为虚拟配对线缆来连接两个虚拟网桥</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/18/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yezh">
      <meta itemprop="description" content="what's you problem">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yezh's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/07/18/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">Unix网络编程卷1学习笔记</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-07-18 19:26:13" itemprop="dateCreated datePublished" datetime="2019-07-18T19:26:13+08:00">2019-07-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-13 17:26:07" itemprop="dateModified" datetime="2020-03-13T17:26:07+08:00">2020-03-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">unix网络编程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Unix网络编程卷1学习笔记"><a href="#Unix网络编程卷1学习笔记" class="headerlink" title="Unix网络编程卷1学习笔记"></a>Unix网络编程卷1学习笔记</h1><h2 id="第3章-套接字编程简介"><a href="#第3章-套接字编程简介" class="headerlink" title="第3章 套接字编程简介"></a>第3章 套接字编程简介</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><table>
<thead>
<tr>
<th>数据类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>sa_family_t</td>
<td>套接字地址结构的地址族</td>
</tr>
<tr>
<td>socklen_t</td>
<td>套接字地址结构的长度，一般为uint32_t</td>
</tr>
<tr>
<td>in_addr_t</td>
<td>IPv4地址，一般为uint32_t</td>
</tr>
<tr>
<td>in_port_t</td>
<td>TCP或UDP端口，一般为uint16_t</td>
</tr>
</tbody></table>
<h3 id="字节排序函数"><a href="#字节排序函数" class="headerlink" title="字节排序函数"></a>字节排序函数</h3><p>大端和小端的区别</p>
<p><strong>网络字节序</strong>：大端</p>
<p>函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">htons</span><span class="params">(<span class="keyword">uint16_t</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">htonl</span><span class="params">(<span class="keyword">uint32_t</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">ntohs</span><span class="params">(<span class="keyword">uint16_t</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">ntohs</span><span class="params">(<span class="keyword">uint32_t</span>)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="字节操纵函数"><a href="#字节操纵函数" class="headerlink" title="字节操纵函数"></a>字节操纵函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bzero(<span class="keyword">void</span>*, <span class="keyword">size_t</span>)   <span class="comment">//归零</span></span><br><span class="line">bcopy(<span class="keyword">const</span> <span class="keyword">void</span>*src, <span class="keyword">void</span> *dest,<span class="keyword">size_t</span> nbytes)  <span class="comment">//复制</span></span><br><span class="line">bcmp(<span class="keyword">const</span> <span class="keyword">void</span>*, <span class="keyword">const</span> <span class="keyword">void</span>*, <span class="keyword">size_t</span>)  <span class="comment">//比较</span></span><br><span class="line"><span class="built_in">memset</span>（<span class="keyword">void</span>*, <span class="keyword">int</span>,<span class="keyword">size_t</span>)       <span class="comment">//归零</span></span><br><span class="line"><span class="built_in">memcpy</span>(<span class="keyword">void</span>*,<span class="keyword">const</span> <span class="keyword">void</span>*,<span class="keyword">size_t</span>)    <span class="comment">//复制</span></span><br><span class="line"><span class="built_in">memcmp</span>(<span class="keyword">const</span> <span class="keyword">void</span>*,<span class="keyword">const</span> <span class="keyword">void</span>*,<span class="keyword">size_t</span>) 		<span class="comment">//比较</span></span><br></pre></td></tr></table></figure>

<h3 id="地址转换函数"><a href="#地址转换函数" class="headerlink" title="地址转换函数"></a>地址转换函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>返回</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>int inet_aton(const char*, struct in_addr*)</code></td>
<td>1：有效</td>
<td>将c字符串转换成一个32位的网络字节序二进制</td>
</tr>
<tr>
<td><code>in_addr_t inet_addr(const char*)</code></td>
<td>有效：32未二进制网络字节序的IPv4地址<br />无效：INADDR_NO</td>
<td>==已废弃==。 与 <code>inet_aton</code> 作用相同,不能处理有限广播地址<code>255.255.255.255</code></td>
</tr>
<tr>
<td><code>char* inet_ntoa(sturct in_addr)</code></td>
<td>指向一个点分十进制数串的指针</td>
<td>将32位的网络字节序二进制IPv4转换为相应的点分十进制数串</td>
</tr>
<tr>
<td><code>int inet_pton(int,const char*, void*)</code></td>
<td>成功：1     输入不是有效格式：0              出错：-1</td>
<td>字符串转换，字符串-&gt;二进制</td>
</tr>
<tr>
<td><code>const char* inet_ntop(int,const void*, char*, size)t</code></td>
<td>成功：指向结果的指针    出错：NULL</td>
<td>字符串转换，二进制-&gt;字符串</td>
</tr>
</tbody></table>
<p><em>p：表达(presentation)|字符串  n：数值（numeric）|二进制</em></p>
<p>errno取值：EINTR</p>
<p>说明 系统调用被一个捕获的信号中断</p>
<h2 id="第4章-基本套接字编程"><a href="#第4章-基本套接字编程" class="headerlink" title="第4章 基本套接字编程"></a>第4章 基本套接字编程</h2><p><img src="https://raw.githubusercontent.com/zdzh/photo/master/20190719175342.png?token=AHGHSTW5MZZUSI22446O5LK5GGJXE" alt=""></p>
<h3 id="基本套接字函数"><a href="#基本套接字函数" class="headerlink" title="基本套接字函数"></a>基本套接字函数</h3><table>
<thead>
<tr>
<th align="left">函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>socket(int family, int type, int protocol)</code></td>
<td>指定期望的通信协议类型，成功则返回套接字描述符（sockfd）</td>
</tr>
<tr>
<td align="left"><code>connect(int sockfd, const struct sockaddr* servaddr, socklen_t addrlen)</code></td>
<td>与服务器建立连接，connect失败则该套接字不再可用，需要close后再socket</td>
</tr>
<tr>
<td align="left"><code>bind(int sockfd, const struct sockaddr* myaddr,socklen_t addrlen)</code></td>
<td>把一个本地协议地址赋予一个套接字。未调用bind时，使用connect或listen，内核将为相应套接字分配临时端口</td>
</tr>
<tr>
<td align="left"><code>listen(int sockfd,int backlog)</code></td>
<td>由服务器调用，调用时使得套接字由CLOSED转为LISTEN状态，同时规定套接字排队的最大连接个数</td>
</tr>
<tr>
<td align="left"><code>accept(int sockfd, struct sockaddr* cliaddr, socklen_t *addr_len)</code></td>
<td>由服务器调用，用于从已完成连接队列队头返回下一个已完成连接，若已完成连接队列为空，则进程被投入睡眠</td>
</tr>
<tr>
<td align="left"><code>int close(int  sockfd)</code></td>
<td>关闭套接字,成功返回0.失败返回-1</td>
</tr>
<tr>
<td align="left"><code>int getsockname(int sockfd, struct sockaddr* localaddr,socklen_t* addrlen)</code></td>
<td>获取与套接字关联的本地协议地址，成功返回0，失败返回-1</td>
</tr>
<tr>
<td align="left"><code>int getpeername(int sockfd,struct sockaddr*peeraddr, socklen_t* addrlen)</code></td>
<td>获取与套接字关联的外地协议地址，成功返回0，失败返回-1</td>
</tr>
<tr>
<td align="left">#### connect</td>
<td></td>
</tr>
</tbody></table>
<p><img src="https://raw.githubusercontent.com/zdzh/photo/master/20190719174918.png?token=AHGHSTXYMRIRFDXRTRBKXSS5GGJHE" alt=""></p>
<ul>
<li>硬错误：指定端口上没有进程在等待与之连接</li>
<li>软错误：目的地不可达</li>
</ul>
<h4 id="accept"><a href="#accept" class="headerlink" title="accept"></a>accept</h4><p>accept函数调用成功时，返回由内核生成的全新描述符，代表与所返回客户的连接。</p>
<p>监听套接字描述符：一个服务器通常只创建一个监听套接字，由socket创建</p>
<p>已连接套接字描述符：内核为每个由服务器进程接受的客户连接创建一个已连接套接字，由accept创建</p>
<h3 id="进程相关函数"><a href="#进程相关函数" class="headerlink" title="进程相关函数"></a>进程相关函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>pid_t fork()</td>
<td>创建新进程，父进程返回子进程进程id，子进程返回0</td>
</tr>
<tr>
<td>exec</td>
<td>execl, execv, execle, execve, execlp, execvp</td>
</tr>
</tbody></table>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p> 了解网络编程基本的套接字函数，知道常用函数的作用及调用顺序，</p>
<p>这章内容主要集中在前面几个基本的套接字函数上，对后面的并发服务器的基本内容大概了解，并发服务器主要和进程创建有关，这部分内容之前了解过一些。</p>
<ul>
<li><input disabled="" type="checkbox"> 什么是套接字和套接字描述符</li>
<li><input disabled="" type="checkbox"> 常用的socket、connect、bind、listen、accept函数的用途？</li>
</ul>
<h2 id="第5章-TCP客户-服务器示例"><a href="#第5章-TCP客户-服务器示例" class="headerlink" title="第5章 TCP客户/服务器示例"></a>第5章 TCP客户/服务器示例</h2><ul>
<li>端口查看命令</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -a | grep 9877</span><br></pre></td></tr></table></figure>

<h3 id="信号处理"><a href="#信号处理" class="headerlink" title="信号处理"></a>信号处理</h3><ul>
<li><code>SIGCHLD</code> – 子进程终止时，发送给父进程</li>
</ul>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul>
<li>fork子进程时，必须捕获SIGCHLD信号</li>
<li>捕获信号时，必须处理被中断的系统调用</li>
<li>SIGCHLD的信号处理函数必须正确编写，应使用waitpid函数以免留下僵死进程​</li>
</ul>
<h2 id="第六章-I-O复用"><a href="#第六章-I-O复用" class="headerlink" title="第六章 I/O复用"></a>第六章 I/O复用</h2><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul>
<li>第一遍看不懂，大概讲I/O复用的内容用于解决内核堵塞与某个输入输出的问题</li>
</ul>
<h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><h3 id="test1-时间获取服务器"><a href="#test1-时间获取服务器" class="headerlink" title="test1 时间获取服务器"></a>test1 时间获取服务器</h3><blockquote>
<p>实现简单的时间获取服务器和客户端</p>
</blockquote>
<h4 id="问题1-客户端例程无法读取服务器返回数据，返回读取错误（test1）"><a href="#问题1-客户端例程无法读取服务器返回数据，返回读取错误（test1）" class="headerlink" title="问题1 客户端例程无法读取服务器返回数据，返回读取错误（test1）"></a>问题1 客户端例程无法读取服务器返回数据，返回读取错误（test1）</h4><ul>
<li><p>原因分析：</p>
<ol>
<li>服务器没有正确开启</li>
<li>客户端配置错误</li>
</ol>
</li>
<li><p>解决方案：</p>
<ol>
<li>对照源代码，确定配置正确</li>
<li>检测服务器是否开启</li>
</ol>
</li>
<li><p>过程：</p>
<ol>
<li>对比发现客户端少调用了connect函数，未与服务器建立连接</li>
<li>查看端口信息,使用<code>netstat -anp</code>未发现程序打开的端口</li>
<li>仔细对照源代码，发现端口的字节序汉书调用错误，调用了<code>htonl</code>，实际应为<code>htons</code></li>
</ol>
</li>
<li><p>结论</p>
<ol>
<li>客户端需要调用socket、connect函数</li>
<li>服务器需要调用socket、bind、listen、accpet函数</li>
<li>注意字节排序函数的调用，l和s所获取到的结果不同</li>
</ol>
</li>
</ul>
<h3 id="test2-回射客户-服务器"><a href="#test2-回射客户-服务器" class="headerlink" title="test2 回射客户/服务器"></a>test2 回射客户/服务器</h3><h4 id="q1-read堵塞"><a href="#q1-read堵塞" class="headerlink" title="q1 read堵塞"></a>q1 read堵塞</h4><ul>
<li>使用read/write读取网络字节时，需要注意堵塞情况的发生。<h2 id="第十三章-守护进程和inetd超级服务器"><a href="#第十三章-守护进程和inetd超级服务器" class="headerlink" title="第十三章 守护进程和inetd超级服务器"></a>第十三章 守护进程和inetd超级服务器</h2>###守护进程转化步骤</li>
</ul>
<ol>
<li>创建子进程</li>
<li>调用<code>setid</code>函数，为子进程创建新会话，从此不再有控制终端</li>
<li>在子进程中再次调用<code>fork</code>函数创建子进程，（确保新进程不会成为终端设备的控制终端）</li>
<li>改变工作目录，将工作目录改为根目录，活根据需要改为其他目录。（守护进程运行时，该工作目录所在的文件系统无法正常拆卸）</li>
<li>关闭所有打开的文件描述符。父进程中可能打开了守护进程不需要的文件描述符，因此需要关闭多余的描述符。</li>
<li>将<code>stdin</code>,<code>stderr</code>,<code>stdout</code>重定向到<code>dev/null</code>。（当守护进程打开与客户关联的套接字时，该套接字可能会打开这些描述符，导致将非预期数据发送给客户）<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3></li>
</ol>
<ul>
<li>守护进程是指进程运行于后台，与控制终端无关</li>
<li>inetd进程用于简化守护进程工作方式，该进程监听了所有守护进程所需套接字，当某个套接字受到客户请求时，inetd进程将创建子进程由于专门处理此请求，在子进程中调用预先设定的程序。</li>
<li>对UDP链接，在子进程接管该套接字后，inetd进程应屏蔽对该套接字的检测，否则可能会产生多个子进程。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/18/%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yezh">
      <meta itemprop="description" content="what's you problem">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yezh's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/07/18/%E7%BA%BF%E7%A8%8B/" class="post-title-link" itemprop="url">线程</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-07-18 18:51:55" itemprop="dateCreated datePublished" datetime="2019-07-18T18:51:55+08:00">2019-07-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-13 17:26:07" itemprop="dateModified" datetime="2020-03-13T17:26:07+08:00">2020-03-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux%E7%BA%BF%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">linux线程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h2 id="线程-1"><a href="#线程-1" class="headerlink" title="线程"></a>线程</h2><h3 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_creat</span><span class="params">(                  <span class="comment">//创建线程，成功返回0，失败返回errcode</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">pthread_t</span>   *thread,        <span class="comment">//线程号     </span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">pthread_attr_t</span> *attr,       <span class="comment">//</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">void</span> *(*func)(<span class="keyword">void</span>*),       <span class="comment">//线程需要运行的函数</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">void</span> *arg                   <span class="comment">//传递给func的参数      </span></span></span></span><br><span class="line"><span class="function"><span class="params">                 )</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(                   <span class="comment">//等待线程终止，成功返回0，失败返回errcode</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">pthread_t</span>   pthread,        <span class="comment">//所等待的线程号</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">void</span>*   retval              <span class="comment">//指向线程返回值</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br></pre></td></tr></table></figure>

<p><strong>在linux中使用pthread.h头文件需要连接lpthread库</strong></p>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><h4 id="组成成分"><a href="#组成成分" class="headerlink" title="组成成分"></a>组成成分</h4><ol>
<li>线程池管理器</li>
<li>工作线程</li>
<li>任务接口</li>
<li>任务队列</li>
</ol>
<h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 初始化线程池</span><br><span class="line">2. 堵塞任务线程</span><br><span class="line">2. 将任务添加进人物队列</span><br><span class="line">3. 判断是否有空闲线程</span><br><span class="line">4. 唤醒线程</span><br><span class="line">5. 完成任务</span><br><span class="line">6. 重新堵塞线程</span><br></pre></td></tr></table></figure>

<h4 id="常见线程池"><a href="#常见线程池" class="headerlink" title="常见线程池"></a>常见线程池</h4><ul>
<li><p>单线程池</p>
<p>每次只有一个线程工作</p>
</li>
<li><p>固定线程池</p>
<p>线程池中线程的数量固定，当达到线程池最大数量时，后续任务进入等待队列</p>
</li>
<li><p>可缓存线程池</p>
<p>当任务超出线程数量时，添加线程，当线程池空闲线程数量过多时，回收部分空间</p>
</li>
<li><p>无限制线程池</p>
<p>线程池大小无限制，支持定时和周期性执行</p>
</li>
</ul>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 控制线程产生数量，控制线程对象的内存消耗</span><br><span class="line">2. 降低系统开销和资源消耗</span><br><span class="line">3. 提高系统响应速度</span><br></pre></td></tr></table></figure>

<h2 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h2><h3 id="线程-2"><a href="#线程-2" class="headerlink" title="线程"></a>线程</h3><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><ul>
<li>命名通道 1. 通道是一个队列而不是常规文件 2. 其读和写是原子操作</li>
<li>共享内存 1. 共享内存段不依赖于进程存在 2. 共享内存段的名字叫关键字 3. 关键字是一个整型数 4. 共享内存段有自己的拥有者己权限位 5. 进程可以连接共享内存段，并获得指针</li>
<li>文件锁</li>
<li>信号量</li>
<li>相关函数 1. select、poll 2. mkfio 3. shmget、shmat、shmctl、shmdt（共享内存） 4.semget、semctl、semop</li>
</ul>
<h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><h3 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(                 <span class="comment">//等待互斥锁解开后锁住互斥量，成功返回0</span></span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">pthread_mutex_t</span> *mutex     <span class="comment">//指向互斥锁</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(                  <span class="comment">//解锁互斥量，成功返回0</span></span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">pthread_mutex_t</span> *mutex,        <span class="comment">//指向互斥量</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span><span class="params">(                      <span class="comment">//挂起线程，等待信号量，成功返回0</span></span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">pthread_cond_t</span>  *cond,          <span class="comment">//</span></span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">pthread_mutex_t</span> *mutex,         <span class="comment">//指向互斥锁对象</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_signal</span><span class="params">(                    <span class="comment">//唤醒等待线程，成功返回0</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">pthread_cond_t</span> *cond)</span>               <span class="comment">//指向条件变量</span></span></span><br></pre></td></tr></table></figure>

<p><em>pthread_cond函数总是和互斥锁在一起使用。此函数先自动释放指定的锁，然后等待条件变量的变化。如果在调用此函数之前，互斥量mutex并没有被锁住，函数执行的结果是不确定的。在返回原调用函数之前，此函数自动将指定的互斥量重新锁住。</em></p>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_init</span><span class="params">(<span class="keyword">sem_t</span> *sem,                <span class="comment">//sem地址  </span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> pshared,                   <span class="comment">//0表示本进程中多个线程间同步，非0表示可以跨进程的同步操作</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span></span>;             <span class="comment">//信号量初值(计数器的值)</span></span><br><span class="line"> <span class="function">P   <span class="keyword">int</span> <span class="title">sem_wait</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;   <span class="comment">// sem-1 如果小于0就阻塞</span></span><br><span class="line"> <span class="function">V    <span class="keyword">int</span> <span class="title">sem_post</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;   <span class="comment">// sem+1</span></span><br></pre></td></tr></table></figure>

<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化和销毁</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_init</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock, <span class="keyword">const</span> <span class="keyword">pthread_rwlockattr_t</span> *<span class="keyword">restrict</span> attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_destroy</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"><span class="comment">// 成功则返回0, 出错则返回错误编号.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_rdlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_wrlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_unlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"><span class="comment">// 成功则返回0, 出错则返回错误编号.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_tryrdlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_trywrlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"><span class="comment">// 成功则返回0, 出错则返回错误编号.</span></span><br></pre></td></tr></table></figure>

<h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><blockquote>
<p>在多线程程序中，很有可能会将同一个文件描述符传递给两个不同的线程。即传递给它们的两个值指向同一个文件描述符。显然如果一个线程中的函数关闭了这个文件，此文件描述符对此进程中的任何线程来说都已经被关闭。</p>
</blockquote>
<blockquote>
<p>fork创建了一个新的进程，并把原调用进程的数据和代码复制给这个新的进程。如果线程中的某函数调用了 fork，只有调用fork的线程在新的进程中运行</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>-[ ] select和epoll</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/18/%E9%B8%9F%E5%93%A5%E7%9A%84%E7%A7%81%E6%88%BF%E8%8F%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yezh">
      <meta itemprop="description" content="what's you problem">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yezh's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/07/18/%E9%B8%9F%E5%93%A5%E7%9A%84%E7%A7%81%E6%88%BF%E8%8F%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">鸟哥的私房菜学习笔记</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-07-18 18:50:53" itemprop="dateCreated datePublished" datetime="2019-07-18T18:50:53+08:00">2019-07-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-13 17:26:07" itemprop="dateModified" datetime="2020-03-13T17:26:07+08:00">2020-03-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%B8%9F%E5%93%A5%E7%9A%84%E7%A7%81%E6%88%BF%E8%8F%9C/" itemprop="url" rel="index"><span itemprop="name">鸟哥的私房菜</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h1><h2 id="第二章-主机规划与磁盘分区"><a href="#第二章-主机规划与磁盘分区" class="headerlink" title="第二章 主机规划与磁盘分区"></a>第二章 主机规划与磁盘分区</h2><h3 id="各硬件在linux中的文件名"><a href="#各硬件在linux中的文件名" class="headerlink" title="各硬件在linux中的文件名"></a>各硬件在linux中的文件名</h3><table>
<thead>
<tr>
<th align="left">设备</th>
<th align="left">文件名</th>
</tr>
</thead>
<tbody><tr>
<td align="left">SCSI/SATA/USB硬盘机</td>
<td align="left">/dev/sd[a-p]</td>
</tr>
<tr>
<td align="left">USB闪存</td>
<td align="left">/dev/sd[a-p]</td>
</tr>
<tr>
<td align="left">virtl/IO界面</td>
<td align="left">/dev/vd[0-7] (用于虚拟机内)</td>
</tr>
<tr>
<td align="left">软盘机</td>
<td align="left">/dev/fd[0-7]</td>
</tr>
<tr>
<td align="left">打印机</td>
<td align="left">/dev/lp[0-2] (15针) /dev/usb/lp[0-15] （USB）</td>
</tr>
<tr>
<td align="left">鼠标</td>
<td align="left">/dev/input/mouse[0-15] /dev/psaux /dev/mouse(当前鼠标)</td>
</tr>
<tr>
<td align="left">CDROM/DVDROM</td>
<td align="left">/dev/scd[0-1] /dev/sr[0-1] /dev/cdrom</td>
</tr>
<tr>
<td align="left">磁带机</td>
<td align="left">/dev/ht0 /dev/st0 /dev/tape</td>
</tr>
<tr>
<td align="left">IDE硬盘机</td>
<td align="left">/dev/hd[a-d]</td>
</tr>
</tbody></table>
<h3 id="主分区和逻辑分区"><a href="#主分区和逻辑分区" class="headerlink" title="主分区和逻辑分区"></a>主分区和逻辑分区</h3><p>主分区： 分区信息记录在分区表内，分区表所存储的分区信息有限</p>
<p>延伸分区：分区信息记录在分区表内，用于割分更多的分区，不可格式化</p>
<p>逻辑分区：分区信息记录在延伸分区表内，割分延伸分区表</p>
<p>GPT没有以上概念</p>
<h3 id="开机流程"><a href="#开机流程" class="headerlink" title="开机流程"></a>开机流程</h3><ol>
<li>BIOS：开机主动执行的固件，会认识第一个可开机的设备；</li>
<li>MBR：第一个可开机设备的第一个扇区内的主要开机记录区块，内含开机管理程序；</li>
<li>开机管理程序（boot loader）：一支可读取核心文件来执行的软件；</li>
<li>核心文件：开始操作系统的功能…</li>
</ol>
<p><img src="assets/1548376920557.png" alt="uefi与BIOS对比"></p>
<h3 id="目录树结构"><a href="#目录树结构" class="headerlink" title="目录树结构"></a>目录树结构</h3><blockquote>
<p>目录树架构（directory tree）就是以根目录（/）为主，然后向下呈现分支状的目录结构的一种文件架构。</p>
</blockquote>
<ul>
<li><strong>挂载</strong></li>
</ul>
<p>利用一个目录当成进入点（挂载点），将磁盘分区的数据放置在该目录下； 也就是说，进入该目录就可以读取该分 区</p>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><ul>
<li><strong>指令格式</strong></li>
</ul>
<blockquote>
<p>$ :一般用户 #： root用户</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">指令</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">date</td>
<td align="left">显示时间</td>
</tr>
<tr>
<td align="left">cal</td>
<td align="left">显示日历</td>
</tr>
<tr>
<td align="left">bc</td>
<td align="left">计算器</td>
</tr>
<tr>
<td align="left">ctrl+c</td>
<td align="left">终止指令</td>
</tr>
<tr>
<td align="left">ctrl+d</td>
<td align="left">键盘输入结束EOF、可取代exit</td>
</tr>
<tr>
<td align="left">shift+pgdn（pgup）</td>
<td align="left">翻页</td>
</tr>
<tr>
<td align="left">sync</td>
<td align="left">将数据同步写入硬盘</td>
</tr>
<tr>
<td align="left">shutdown</td>
<td align="left">关机</td>
</tr>
<tr>
<td align="left">reboot</td>
<td align="left">重启</td>
</tr>
<tr>
<td align="left">chgrp</td>
<td align="left">改变档案群组</td>
</tr>
<tr>
<td align="left">chown</td>
<td align="left">改变档案拥有者</td>
</tr>
<tr>
<td align="left">chmod</td>
<td align="left">改变档案权限</td>
</tr>
<tr>
<td align="left">cat</td>
<td align="left">读取文件内容</td>
</tr>
<tr>
<td align="left">read</td>
<td align="left">读取键盘输入</td>
</tr>
<tr>
<td align="left">declare或typeset</td>
<td align="left">声明变量名</td>
</tr>
</tbody></table>
<p>[Tab] 接在一串指令的第一个字的后面,则为 “ 命令补全 ” ; [Tab] 接在一串指令的第二个字以后时,则为 “ 文件补齐 ” !</p>
<h4 id="man"><a href="#man" class="headerlink" title="man"></a>man</h4><p>（man man） |编号 |代表内容| |1| 使用者在 shell 环境中可以操作的指令或可可执行文件| |2 |系统核心可调用的函数与工具等| |3| 一些常用的函数( function )与函数库( library ),大部分为 C 的函数库( libc )| |4| 设备文件的说明,通常在 /dev 下的文件| |5| 配置文件或者是某些文件的格式| |6| 游戏( games )| |7| 惯例与协定等,例如 Linux 文件系统、网络协定、 ASCII code 等等的说明| |8| 系统管理员可用的管理指令| |9| 跟 kernel 有关的文件|</p>
<h4 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h4><p>可以通过man或info指令获取指令的详细信息</p>
<h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><h4 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h4><ul>
<li>第一个字符<ul>
<li>d 目录</li>
<li><ul>
<li>档案</li>
</ul>
</li>
<li>l 连结档</li>
<li>b 装置文件里的可供存储的接口设备</li>
<li>c 装置文件里的串行端口设备</li>
</ul>
</li>
<li>三个一组，分别为rwx，分别代表读、写、可执行。第一组为拥有者、第二组为同组群、第三为其他</li>
</ul>
<h4 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h4><ul>
<li>正规文件【-】<ol>
<li>纯文本文件</li>
<li>二进制文件</li>
<li>数据份格式文件</li>
</ol>
</li>
<li>目录【d】</li>
<li>链接文件【l】</li>
<li>设备与设备文件<ol>
<li>区块设备文件【b】：存储数据的周边设备，硬盘等 . 字符设备文件【c】：一次性读取设备，鼠标、键盘等</li>
</ol>
</li>
<li>数据接口文件【s】</li>
<li>输出传输档【p】</li>
</ul>
<h4 id="目录配置依据"><a href="#目录配置依据" class="headerlink" title="目录配置依据"></a>目录配置依据</h4><p>|不变的|/usr（软件放置处）/opt（第三方协议）|/etc（配置文件） /boot（开机与核心文档）| |可变的|/var/mail（使用者邮件信箱） /var/spool/news（新闻群组）|/var/run（程序相关） /var/lock（程序相关)|</p>
<ul>
<li>目录定义 / ( root, 根目录):与开机系统有关; /usr ( unix software resource ):与软件安装 / 执行有关; /var ( variable ):与系统运行过程有关。</li>
</ul>
<h4 id="笔记-1"><a href="#笔记-1" class="headerlink" title="笔记"></a>笔记</h4><ul>
<li>-x权限对目录十分重要，拥有x权限才可以将该目录设为工作目录，才能执行其他指令</li>
<li>-r权限可以读取到目录内的文件列表，但不能进入目录</li>
<li>-w权限可以修改目录内的文件，但不能修改文件内容，使用时需要拥有x权限 -linux文件是否可以执行与文件扩展名无关，其通过文件属性设置</li>
<li>文件以<code>.</code>开头表示隐藏文件</li>
<li>Linux 的每个文件中,可分别给予使用者、群组与其他人三种身份个别的 rwx 权限;</li>
<li>群组最有用的功能之一,就是当你在团队开发资源的时候,且每个帐号都可以有多个群组的支持;</li>
<li>利用 ls -l 显示的文件属性中,第一个字段是文件的权限,共有十个位,第一个位是文件类型, 接下来三个为一组共三组,为使用者、群组、其他人的权限,权限有 r,w,x 三种;</li>
<li>如果文件名之前多一个 “ . ” ,则代表这个文件为 “ 隐藏文件 ” ;</li>
<li>若需要 root 的权限时,可以使用 su - 这个指令来切换身份。处理完毕则使用 exit 离开 su 的指令环境。</li>
<li>更改文件的群组支持可用 chgrp ,修改文件的拥有者可用 chown ,修改文件的权限可用 chmod</li>
<li>chmod 修改权限的方法有两种,分别是符号法与数字法,数字法中 r,w,x 分数为 4,2,1 ; 对文件来讲,权限的性能为: r :可读取此一文件的实际内容,如读取文本文件的文字内容等; w :可以编辑、新增或者是修改该文件的内容(但不含删除该文件); x :该文件具有可以被系统执行的权限。</li>
<li>对目录来说,权限的性能为: r ( read contents in directory ) w ( modify contents of directory ) x ( access directory )</li>
<li>要开放目录给任何人浏览时,应该至少也要给予 r 及 x 的权限,但 w 权限不可随便给;</li>
<li>能否读取到某个文件内容,跟该文件所在的目录权限也有关系 (目录至少需要有 x 的权限)。</li>
<li>Linux 文件名的限制为:单一文件或目录的最大容许文件名为 255 个英文字符或 128 个中文字符;</li>
<li>根据 FHS 的官方文件指出, 他们的主要目的是希望让使用者可以了解到已安装软件通常放置于那个目录下</li>
<li>FHS 订定出来的四种目录特色为: shareable, unshareable, static, variable 等四类;</li>
<li>FHS 所定义的三层主目录为: /, /var, /usr 三层而已;</li>
<li>绝对路径文件名为从根目录 / 开始写起,否则都是相对路径的文件名。</li>
</ul>
<h3 id="文件与目录管理"><a href="#文件与目录管理" class="headerlink" title="文件与目录管理"></a>文件与目录管理</h3><p>|. |代表此层目录| |..|代表上一层目录| |-|代表前一个工作目录| |<del>|代表 “ 目前使用者身份 ” 所在的主文件夹| |</del>account|代表 account 这个使用者的主文件夹( account 是个帐号名称)|</p>
<ul>
<li>常见目录指令 |cd|变更目录| |pwd|显示目前的目录| |mkdir|创建新目录| |rmdir|删除空目录|</li>
</ul>
<h3 id="vi和vim"><a href="#vi和vim" class="headerlink" title="vi和vim"></a>vi和vim</h3><h2 id="第十章-BASH"><a href="#第十章-BASH" class="headerlink" title="第十章 BASH"></a>第十章 BASH</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="变量使用与设置"><a href="#变量使用与设置" class="headerlink" title="变量使用与设置"></a>变量使用与设置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myname&#x3D;yezh</span><br></pre></td></tr></table></figure>

<ul>
<li>等号两边不能有空格</li>
<li>使用单反引号[<code>command</code>]或$(command)可以执行额外的命令</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">version&#x3D;$(uname -r)</span><br></pre></td></tr></table></figure>

<ul>
<li>双引号内的特殊字符如<code>$</code>保持原有特性</li>
<li>单引号内特殊字符与一般字符相同 可使用<code>\</code>将特殊字符转化为一般字符</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">myhome=<span class="string">"<span class="variable">$HOME</span>"</span></span><br><span class="line"><span class="comment">#myhome = /home/yeah</span></span><br><span class="line"></span><br><span class="line">myroom=<span class="string">'$HOME'</span></span><br><span class="line"><span class="comment">#myroom=$HOME</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用<code>${name}</code>or<code>$&quot;name&quot;</code>可扩展变量内容</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myroom=<span class="variable">$HOME</span>  <span class="comment">#myhome = /home/yeah</span></span><br><span class="line">myroom=<span class="variable">$&#123;myhome&#125;</span>:/home/bin</span><br><span class="line"><span class="comment">#myhome = /home/yeah:/home/bin</span></span><br></pre></td></tr></table></figure>

<ul>
<li>using variable on other program with <code>export variablename</code></li>
<li>canncel variable with <code>unset variablename</code></li>
<li>父进程定义的变量无法在子进程中使用</li>
</ul>
<h4 id="环境变量功能"><a href="#环境变量功能" class="headerlink" title="环境变量功能"></a>环境变量功能</h4><blockquote>
<p><strong>子进程只继承父进程的环境变量，不继承自定义变量</strong></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看环境变量</span></span><br><span class="line">env</span><br><span class="line"><span class="built_in">export</span></span><br><span class="line"><span class="comment">#查看所有变量（含环境变量和自定义变量）</span></span><br><span class="line"><span class="built_in">set</span></span><br></pre></td></tr></table></figure>

<h4 id="变量内容的删除、替换"><a href="#变量内容的删除、替换" class="headerlink" title="变量内容的删除、替换"></a>变量内容的删除、替换</h4><table>
<thead>
<tr>
<th align="left"></th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>#</code></td>
<td align="left">符合删除文字的最短字符串</td>
</tr>
<tr>
<td align="left"><code>##</code></td>
<td align="left">符合删除文字的最长字符串</td>
</tr>
<tr>
<td align="left"><code>%</code></td>
<td align="left">从后往前删除</td>
</tr>
<tr>
<td align="left"><code>%%</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>/old/new</code></td>
<td align="left">替换第一个相符关键字</td>
</tr>
<tr>
<td align="left"><code>//old/new</code></td>
<td align="left">替换全部相符关键字</td>
</tr>
</tbody></table>
<h2 id="第十一章-正则表达式"><a href="#第十一章-正则表达式" class="headerlink" title="第十一章 正则表达式"></a>第十一章 正则表达式</h2><table>
<thead>
<tr>
<th align="left">特殊符号</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>[:alnum:]</strong></td>
<td align="left">大小写字母与数组，即0<del>9. a</del>z, A~Z</td>
</tr>
<tr>
<td align="left"><strong>[:alpha:]</strong></td>
<td align="left">大小写字母，a<del>z, A</del>Z</td>
</tr>
<tr>
<td align="left">[:blank:]</td>
<td align="left">空格键与[tab]键</td>
</tr>
<tr>
<td align="left">[:cntrl:]</td>
<td align="left">控制按键，CR、LF、Tab、Del等</td>
</tr>
<tr>
<td align="left"><strong>[:digit:]</strong></td>
<td align="left">数字，0~9</td>
</tr>
<tr>
<td align="left">[:graph:]</td>
<td align="left">除空格键和[tab]以外所有按键</td>
</tr>
<tr>
<td align="left"><strong>[:lower:]</strong></td>
<td align="left">小写字母a~z</td>
</tr>
<tr>
<td align="left">[:print:]</td>
<td align="left">可打印字符</td>
</tr>
<tr>
<td align="left">[:punct:]</td>
<td align="left">标点符号，“ ? . /等</td>
</tr>
<tr>
<td align="left"><strong>[:upper:]</strong></td>
<td align="left">大写字母A~Z</td>
</tr>
<tr>
<td align="left">[:space:]</td>
<td align="left">任何会产生空白的字符，空格，TAB, CR等</td>
</tr>
<tr>
<td align="left">[:xdigit:]</td>
<td align="left">十六进制数字类型，包括0~ 9，a<del>f， A</del>F</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">RE 字符</th>
<th align="left">意义与范例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">^word</td>
<td align="left">意义:待搜寻的字串( word )在行首! 范例:搜寻行首为 # 开始的那一行,并列出行号 <code>grep -n &#39;^#&#39; regular_express.txt</code></td>
</tr>
<tr>
<td align="left">word$</td>
<td align="left">意义:待搜寻的字串( word )在行尾! 范例:将行尾为!的那一行打印出来,并列出行号 <code>grep -n &#39;!$&#39; regular_express.txt</code></td>
</tr>
<tr>
<td align="left">.</td>
<td align="left">意义:代表 “ 一定有一个任意字符 ” 的字符! 范例:搜寻的字串可以是 (eve)(eae)(eee)(ee),但不能仅有(ee)!亦即e与e中间“一定”仅有一个字符,而空白字符也是字符! <code>grep -n &#39;e.e&#39; regular_express.txt</code></td>
</tr>
<tr>
<td align="left">\</td>
<td align="left">意义:转义字符,将特殊符号的特殊意义去除! 范例:搜寻含有单引号 ‘ 的那一行! `grep -n ‘ regular_express.txt</td>
</tr>
<tr>
<td align="left">*</td>
<td align="left">意义:重复零个到无穷多个的前一个 RE 字符 范例:找出含有 ( es ) ( ess ) ( esss ) 等等的字串,注意,因为 * 可以是 0 个,所以 es 也是符合带搜寻字串。另外,因为 * 为重复 “ 前一个 RE 字符 ” 的符号, 因此,在 * 之前必须要紧接着一个 RE 字符喔!例如任意字符则为“.<em>”! `grep -n ‘ess</em>‘ regular_express.txt`</td>
</tr>
<tr>
<td align="left">[list]</td>
<td align="left">意义:字符集合的 RE 字符,里面列出想要撷取的字符! 范例:搜寻含有 ( gl ) 或 ( gd ) 的那一行,需要特别留意的是,在 [] 当中 “ 谨代表一个待搜寻的字符 ” , 例如 “a[afl]y ” 代表搜寻的字串可以是 aay, afy, aly 即 [afl] 代表 a 或 f 或 l 的意思! <code>grep -n &#39;g[ld]&#39; regular_express.txt</code></td>
</tr>
<tr>
<td align="left">[n1-n2]</td>
<td align="left">意义:字符集合的 RE 字符,里面列出想要撷取的字符范围! 范例:搜寻含有任意数字的那一行!需特别留意,在字符集合 [] 中的减号 - 是有特殊意义的,他代表两个字符之间的所有连续字符!但这个连续与否与 ASCII 编码有关,因此,你的编码需要设置正确(在 bash 当中,需要确定 LANG 与 LANGUAGE 的变量是否正确!) 例如所有大写字符则为 [A-Z] <code>grep -n &#39;[A-Z]&#39; regular_express.txt</code></td>
</tr>
<tr>
<td align="left"><code>[^list]</code></td>
<td align="left">意义:字符集合的 RE 字符,里面列出不要的字串或范围! 范例:搜寻的字串可以是 ( oog ) ( ood ) 但不能是 ( oot ) ,那个 ^ 在 [] 内时,代表的意义是 “ 反向选择 ” 的意思。 例如,我不要大写字符,则为 [^A-Z] 。但是,需要特别注意的是,如果以 grep -n [^A-Z] regular_express.txt 来搜寻,却发现该文件内的所有行都被列出,为什么?因为这个 [^A-Z] 是 “ 非大写字符 ” 的意思, 因为每一行均有非大写字符,例如第一行的”Open Source” 就有 p,e,n,o…. 等等的小写字<code>grep -n &#39;oo[^t]&#39; regular_express.txt</code></td>
</tr>
<tr>
<td align="left">{n,m}</td>
<td align="left">意义:连续 n 到 m 个的 “ 前一个 RE 字符 ” 意义:若为 {n} 则是连续 n 个的前一个 RE 字符, 意义:若是 {n,} 则是连续 n 个以上的前一个 RE 字符!  范例:在 g 与 g 之间有 2 个到 3 个的 o 存在的字串,亦即 ( goog )( gooog ) <code>grep -n &#39;go\{2,3\}g&#39; regular_express.txt</code></td>
</tr>
</tbody></table>
<p><img src="vscode-resource:/c:/Users/yezhihuo/Documents/note/home/yeah/study/studynote/%E9%B8%9F%E5%93%A5%E7%9A%84%E7%A7%81%E6%88%BF%E8%8F%9C/assets/%E6%89%A9%E5%B1%95%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.png" alt="re"></p>
<h2 id="第十二章-shell脚本"><a href="#第十二章-shell脚本" class="headerlink" title="第十二章 shell脚本"></a>第十二章 shell脚本</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#program</span></span><br><span class="line"><span class="comment">#  creat one file named by user's input and date command</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">"please input file name: "</span> fileuser</span><br><span class="line">filename=<span class="variable">$&#123;fileuser:-"backup"&#125;</span></span><br><span class="line">datestr=$(date +%y%m%d)</span><br><span class="line">filename=<span class="variable">$&#123;filename&#125;</span>-<span class="variable">$&#123;datestr&#125;</span></span><br><span class="line">touch <span class="string">"<span class="variable">$&#123;filename&#125;</span>"</span></span><br></pre></td></tr></table></figure>

<p><strong>对变量赋值时，等号两边不能有空格</strong></p>
<h3 id="执行方式"><a href="#执行方式" class="headerlink" title="执行方式"></a>执行方式</h3><ol>
<li><p>source<br>直接在父进程中运行脚本</p>
</li>
<li><p>sh script<br>在子进程中运行脚本</p>
</li>
<li><p>./script 需要将文件设置为可执行文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x &lt;filename&gt;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h3><p>bash命令行参数可以用<code>$0</code>,<code>$1</code>…获取</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#program:test</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"the program name is: <span class="variable">$0</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"the frist arg is: <span class="variable">$1</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"the second arg is: <span class="variable">$2</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># bash</span></span><br><span class="line">$ sh <span class="built_in">test</span> 1 2 3</span><br><span class="line">the program name is: <span class="built_in">test</span></span><br><span class="line">the frist arg is: 1</span><br><span class="line">the second arg is: 2</span><br></pre></td></tr></table></figure>



<h3 id="判断式"><a href="#判断式" class="headerlink" title="判断式"></a>判断式</h3><h4 id="test命令"><a href="#test命令" class="headerlink" title="test命令"></a><code>test</code>命令</h4><h4 id="判断符号"><a href="#判断符号" class="headerlink" title="[ ]判断符号"></a><code>[ ]</code>判断符号</h4>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yezh">
      <meta itemprop="description" content="what's you problem">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yezh's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/07/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">操作系统</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-07-18 18:47:42" itemprop="dateCreated datePublished" datetime="2019-07-18T18:47:42+08:00">2019-07-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-13 17:26:07" itemprop="dateModified" datetime="2020-03-13T17:26:07+08:00">2020-03-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第一章-引论"><a href="#第一章-引论" class="headerlink" title="第一章 引论"></a>第一章 引论</h1><h2 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h2><ul>
<li>是计算机硬件的第一层软件</li>
<li>是对硬件系统的首次扩充</li>
<li>对内是<strong>资源管理者</strong>，对外是<strong>用户接口</strong></li>
</ul>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul>
<li><p>方便性</p>
<p>配置os后可使操作系统更容易使用</p>
</li>
<li><p>有效性</p>
<ol>
<li>提高系统资源利用率</li>
<li>提高系统的吞吐量</li>
</ol>
</li>
<li><p>可扩充性</p>
<p>os必须具有很好的可扩充性，方能适应计算机硬件、体系结构以及应用发展的要求</p>
</li>
<li><p>开放性</p>
<p>为使来自<strong>不同厂家</strong>的计算机和设备能够通过网络加以<strong>集成化</strong>，并能正确、有效的<strong>协同工作</strong>，实现应用的<strong>可移植性和互操作性</strong>，要求操作系统必须<strong>提供统一的开放环境</strong>，进而要求os具有开放性。</p>
</li>
</ul>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ol>
<li><p>作为用户与计算机硬件系统之间的接口</p>
<p><img src="assets/1563449315086.png" alt="1563449315086"></p>
</li>
<li><p>作为计算机系统资源的管理者</p>
<p>四类计算机资源：处理器、存储器、I/O设备以及信息（数据和程序）</p>
<p>os的主要功能是针对四类资源进行有效管理：</p>
<ul>
<li>处理机管理，用于分配和控制处理机</li>
<li>存储器管理，主要负责内存的分配和回收</li>
<li>I/O设备管理，负责I/O设备的分配和操纵</li>
<li>文件管理，负责文件的存取、共享和保护</li>
</ul>
</li>
<li><p>实现了对计算机资源的抽象</p>
</li>
</ol>
<h2 id="发展过程"><a href="#发展过程" class="headerlink" title="发展过程"></a>发展过程</h2><ol>
<li><p>单道批处理系统</p>
<p>系统对作用的处理是<strong>成批进行</strong>的，且在内存中始终只存在一道作业。</p>
<p>特征：自动性、顺序性、单道性</p>
</li>
<li><p>多批道处理系统</p>
<ul>
<li>优缺点：资源利用率高、系统吞吐量大、平均周转时间长、无交互能力</li>
</ul>
</li>
<li><p>分时系统</p>
<p>特征：多路性、独立性、及时性、交互性</p>
</li>
<li><p>实时操作系统</p>
</li>
<li><p>微机操作系统</p>
<p>单用户单任务操作系统</p>
<p>单用户多任务操作系统</p>
<p>多用户多任务操作系统</p>
</li>
</ol>
<h2 id="基本特性"><a href="#基本特性" class="headerlink" title="基本特性"></a>基本特性</h2><ol>
<li><p>并行和并发</p>
<p>并行：两个或多个事件在<strong>同一刻</strong>发生；</p>
<p>并发：两个或多个事件在<strong>同一时间间隔</strong>内发生</p>
</li>
<li><p>进程</p>
<p>概念：在系统中能<strong>独立运行</strong>并作为<strong>资源分配的基本单位</strong>，由一组机器指令、数据和堆栈组成。是一个能独立运行的实体</p>
<p>通常的程序是静态实体，在多道程序系统中不能独立运行</p>
<p>引入进程的目的是为了使多个程序能并发运行</p>
</li>
<li><p>共享</p>
<p>互斥共享方式</p>
<p>同时访问方式</p>
</li>
<li><p>虚拟</p>
<p>时分复用技术：虚拟处理机技术/虚拟设备技术</p>
<p>空分复用技术</p>
</li>
<li><p>异步</p>
</li>
</ol>
<h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><ol>
<li><p>处理机管理功能</p>
<ul>
<li>进程控制</li>
<li>进程同步</li>
<li>进程通信</li>
<li>调度：作业调度/进程调度</li>
</ul>
</li>
<li><p>存储器管理功能</p>
<p>内存分配：静态/动态分配方式</p>
<p>内存保护</p>
<p>地址映射</p>
<p>内存扩充：请求调入功能/置换功能</p>
</li>
<li><p>设备管理功能</p>
<ul>
<li>缓存管理</li>
<li>设备分配</li>
<li>设备处理</li>
</ul>
</li>
<li><p>文件管理功能</p>
<ul>
<li>文件存储空间管理</li>
<li>目录管理</li>
<li>文件的读/写管理保护</li>
</ul>
</li>
<li><p>操作系统与用户之间的接口</p>
<ul>
<li>联机用户接口</li>
<li>脱机用户接口</li>
<li>图形用户接口</li>
</ul>
</li>
<li><p>现代操作系统的新功能</p>
</li>
<li><ul>
<li>系统安全</li>
<li>网络的功能和服务</li>
<li>支持多媒体</li>
</ul>
</li>
</ol>
<h2 id="结构设计"><a href="#结构设计" class="headerlink" title="结构设计"></a>结构设计</h2><ol>
<li>传统操作系统结构<ul>
<li>无结构操作系统（软件危机）</li>
<li>模块化结构os（高内聚低耦合——横向关联）</li>
<li>分层式结构os（隐马尔可夫链——纵向关联）</li>
</ul>
</li>
<li>C/S模式（客户/服务器）</li>
<li>面向对象的程序设计</li>
<li>微内核os结构（优缺点）<ul>
<li>足够小的内核</li>
<li>C/S模式</li>
<li>应用“机制和策略分离”原理</li>
<li>采用面向对象技术</li>
</ul>
</li>
</ol>
<h1 id="第二章-进程"><a href="#第二章-进程" class="headerlink" title="第二章 进程"></a>第二章 进程</h1><h2 id="前趋图和程序执行"><a href="#前趋图和程序执行" class="headerlink" title="前趋图和程序执行"></a>前趋图和程序执行</h2><ol>
<li>前趋图是一个<strong>有向无循环图</strong>，记为DAG，用于描述进程之间执行的<strong>前后关系</strong>。</li>
</ol>
<p>结点：程序段或进程，乃至一条语句</p>
<p>有向边：结点之间存在的前趋关系</p>
<p>初始结点：无前趋的结点</p>
<p>终止结点：无后继的结点</p>
<p>重量：该结点所含有的程序量或结点的执行时间</p>
<p>==前趋图中不存在循环==</p>
<ol>
<li>程序顺序执行的特征</li>
</ol>
<ul>
<li>顺序性：处理机的操作严格按照程序所规定的顺序执行</li>
<li>封闭性：程序在封闭环境下执行，即运行时独占全机资源</li>
<li>可再现性：只要执行环境和初始条件相同，不论如何执行，都获得相同的结果</li>
</ul>
<ol>
<li><p>程序并发运行</p>
<p>特征：间断性、失去封闭性、不可再现性</p>
</li>
</ol>
<h2 id="进程描述"><a href="#进程描述" class="headerlink" title="进程描述"></a>进程描述</h2><ol>
<li><p>进程定义：是进程实体的<strong>运行过程</strong>，是系统进行<strong>资源调度</strong>的一个<strong>独立单位</strong></p>
<p>进程控制块（pcb）</p>
<ul>
<li>进程标识符：内部标识符（由操作系统创建）外部标识符（由创建者提供）</li>
<li>处理机状态：主要由处理机的各种寄存器的内容组成（通用寄存器、指令计数器、程序状态字psw、用户栈指针）</li>
<li>进程调度信息：进程状态、进程优先级、其他信息、事件（堵塞原因）</li>
<li>进程控制信息<ul>
<li>程序和数据地址</li>
<li>进程同步和通信机制</li>
<li>资源清单</li>
<li>链接指针</li>
</ul>
</li>
</ul>
<p>进程实体：由程序段、相关数据段和pcb三部分构成</p>
</li>
<li><p>特征</p>
<ul>
<li><p>动态性：<strong>最基本特征</strong>。“由创建而产生，因调度而执行，由撤销而消亡”</p>
</li>
<li><p>并发性：多个进程实体同存于内存中，且在<strong>一段时间</strong>内能独立运行</p>
</li>
<li><p>独立性：在传统os中，独立性是指进程实体是一个能独立运行、独立分配资源和独立接收调度的基本单位</p>
</li>
<li><p>异步性：进程实体按异步方式运行</p>
<p><img src="assets/1563449373193.png" alt="三种基本状态及其转换"></p>
</li>
</ul>
</li>
</ol>
<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><p>进程控制是进程管理中<strong>最基本的功能</strong>，用于创建一个新进程，终止一个已完成进程，或终止一个因出现某事件而使其无法运行下去的进程，还可负责进程运行中的状态转换。</p>
<ol>
<li><p>操作系统内核</p>
<ol>
<li>系统态（管态）、用户态（目态）</li>
<li>支撑功能：中断管理、时钟管理、原语操作</li>
<li>资源管理功能：进程、存储器、设备管理</li>
</ol>
</li>
<li><p>进程创建</p>
<p>进程图：描述一个进程家族关系的<strong>有向树</strong></p>
<p><img src="assets/1544515463767.png" alt="有向树"></p>
<p>引起创建进程的事件</p>
<ul>
<li>用户登录</li>
<li>作业调度</li>
<li>提供服务</li>
<li>应用请求</li>
</ul>
<p>引起进程终止的事件</p>
<ul>
<li>正常结束</li>
<li>异常结束</li>
<li>外界干预</li>
</ul>
<p>引起进程堵塞或唤醒事件</p>
<ul>
<li>请求系统服务</li>
<li>等待操作完成</li>
<li>新数据尚未到达</li>
<li>等待新任务的到达</li>
</ul>
</li>
</ol>
<h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><ol>
<li>基本概念<ol>
<li>制约关系：间接相互制约关系、直接相互制约关系</li>
<li>临界资源</li>
<li>临界区</li>
<li>同步机制规则<ol>
<li>空闲让进</li>
<li>忙则等待</li>
<li>有限等待</li>
<li>让权等待</li>
</ol>
</li>
</ol>
</li>
<li>硬件同步机制</li>
<li>信号量机制<ul>
<li>整型信号量</li>
<li>记录型信号量</li>
</ul>
</li>
</ol>
<h1 id="第三章-处理机"><a href="#第三章-处理机" class="headerlink" title="第三章 处理机"></a>第三章 处理机</h1><h2 id="处理机调度的层次和调度算法的目标"><a href="#处理机调度的层次和调度算法的目标" class="headerlink" title="处理机调度的层次和调度算法的目标"></a>处理机调度的层次和调度算法的目标</h2><h3 id="层次"><a href="#层次" class="headerlink" title="层次"></a>层次</h3><ol>
<li>高级调度：又称长程调度或作业调度，对象是作业</li>
<li>低级调度：又称进程调度或短程调度，对象是进程</li>
<li>中级调度：又称内存调度</li>
</ol>
<h3 id="目标-1"><a href="#目标-1" class="headerlink" title="目标"></a>目标</h3><ol>
<li>处理机调度的共同目标<ul>
<li>资源利用率：<code>CPU利用率=有效工作时间/总时间</code></li>
<li>公平性：公平性是相对的</li>
<li>平衡性：保持系统资源使用的平衡性</li>
<li>策略强制执行</li>
</ul>
</li>
<li>批处理系统的目标<ul>
<li>平均周转时间短</li>
<li>系统吞吐量高</li>
<li>处理机利用率高</li>
</ul>
</li>
<li>分时系统目标<ul>
<li>响应时间快</li>
<li>均衡性</li>
</ul>
</li>
<li>实时系统目标<ul>
<li>截止时间的保证</li>
<li>可预测性</li>
</ul>
</li>
</ol>
<h2 id="作业和作业调度"><a href="#作业和作业调度" class="headerlink" title="作业和作业调度"></a>作业和作业调度</h2><h3 id="批处理系统中的作业"><a href="#批处理系统中的作业" class="headerlink" title="批处理系统中的作业"></a>批处理系统中的作业</h3><p>作业运行的三个阶段和三种状态</p>
<ul>
<li>收容状态：建立jcb</li>
<li>运行状态：建立pcb</li>
<li>完成状态：回收pcb和jcb</li>
</ul>
<h3 id="作业调度的主要任务"><a href="#作业调度的主要任务" class="headerlink" title="作业调度的主要任务"></a>作业调度的主要任务</h3><h3 id="作业调度算法"><a href="#作业调度算法" class="headerlink" title="作业调度算法"></a>作业调度算法</h3><ol>
<li><p>先来先服务（FCFS）</p>
</li>
<li><p>短作业优先调度</p>
<p>FCFS算法有利于长作业，而不利于作业</p>
<p>SJF：短作业优先调度算法</p>
<p>SPF：短进程优先调度算法</p>
<p>缺点：</p>
<ul>
<li>对长作业不利</li>
<li>完全未考虑作业的紧迫程度</li>
<li>不一定真正做到短作业优先调度</li>
</ul>
</li>
<li><p>优先级调度算法（FPF）</p>
<ol>
<li>优先权调度算法类型<ul>
<li>非抢占式优先</li>
<li>抢占式优先</li>
</ul>
</li>
<li>优先权类型：静态优先权、动态优先权</li>
</ol>
</li>
<li><p>高响应比优先调度算法</p>
</li>
</ol>
<h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><h3 id="进程调度任务"><a href="#进程调度任务" class="headerlink" title="进程调度任务"></a>进程调度任务</h3><ol>
<li>保存处理机的现场信息</li>
<li>按某种算法选取进程</li>
<li>把处理器分配给进程</li>
</ol>
<h3 id="进程调度机制"><a href="#进程调度机制" class="headerlink" title="进程调度机制"></a>进程调度机制</h3><ol>
<li>排队器</li>
<li>分派器</li>
<li>上下文切换器</li>
</ol>
<h3 id="调度方式"><a href="#调度方式" class="headerlink" title="调度方式"></a>调度方式</h3><ul>
<li>非抢占方式：突发事件、I/O请求、进程通信</li>
<li>抢占方式：优先权原则、短进程优先原则、时间片原则</li>
</ul>
<h3 id="轮转调度算法"><a href="#轮转调度算法" class="headerlink" title="轮转调度算法"></a>轮转调度算法</h3><h3 id="多机反馈队列算法"><a href="#多机反馈队列算法" class="headerlink" title="多机反馈队列算法"></a>多机反馈队列算法</h3><h2 id="死锁概述"><a href="#死锁概述" class="headerlink" title="死锁概述"></a>死锁概述</h2><h3 id="资源问题和死锁原因"><a href="#资源问题和死锁原因" class="headerlink" title="资源问题和死锁原因"></a>资源问题和死锁原因</h3><ul>
<li>竞争资源：可重用性资源和消耗性资源、可抢占性资源和不可抢占性资源</li>
<li>进程间推进顺序非法：请求和释放资源顺序不当</li>
</ul>
<ol>
<li>竞争不可抢占性资源引起资源死锁</li>
<li>竞争可消耗性资源引起死锁</li>
<li>进程推进顺序不当引起死锁</li>
</ol>
<h3 id="死锁的定义、必要条件和处理方法"><a href="#死锁的定义、必要条件和处理方法" class="headerlink" title="死锁的定义、必要条件和处理方法"></a>死锁的定义、必要条件和处理方法</h3><ol>
<li>定义</li>
<li>必要条件<ul>
<li>互斥条件</li>
<li>请求和保持条件</li>
<li>不剥夺条件</li>
<li>环路等待条件</li>
</ul>
</li>
<li>处理死锁方法<ul>
<li>预防死锁：通过设置某些限制条件，破坏产生死锁的四个必要条件中的一个或多个，来预防死锁</li>
<li>避免死锁：在资源动态分配过程中，用某种方法去防止系统进入不安全状态</li>
<li>检测死锁：通过系统所设置的检测机构及时检测出死锁的发生，并精确地确定与死锁有关的进程和资源，然后采取适当的措施，从系统中清除已发生的死锁</li>
<li>解除死锁：与检测死锁向配套的一种措施</li>
</ul>
</li>
</ol>
<h2 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h2><ol>
<li>摒弃“请求和保持”条件：所有进程开始前都必须一次性申请其在整个运行过程中所需的全部资源</li>
<li>破坏“不可抢占”条件：进程逐个提出对资源的请求。当进程提出新的资源请求而得不到满足时，释放其已保持的所有资源，待以后需要时重新申请。</li>
<li>破坏“环路等待”条件：所有资源按线性排队，所有进程对资源的请求必须严格按照资源序号递增的次序提出</li>
</ol>
<p>##　避免死锁</p>
<ol>
<li>允许进程动态申请资源，但系统在进行资源分配前，先计算资源分配的安全性，如此次分配导致系统进入不安全状态，则令进程等待。<ul>
<li>安全状态：系统能够按某种进程顺序来为每个进程分配其所需资源，直至满足每个进程对资源的最大需求。使每个进程可以顺利完成。</li>
<li>并非所有不安全状态都必然会转为死锁状态，但当系统进入不安全状态时，便有可能进入死锁状态。</li>
</ul>
</li>
<li>银行家算法</li>
<li>安全性算法</li>
</ol>
<p>##　 死锁的检测和解除</p>
<ol>
<li>死锁的检测<ul>
<li>保存有关资源的请求和分配信息</li>
<li>提供一种算法，以利用这些信息来检测系统是否已经进入死锁状态</li>
<li>死锁定理：当且仅当s状态的<strong>资源分配图</strong>是不可完全简化的（充分条件）</li>
</ul>
</li>
<li>死锁的解除<ul>
<li>剥夺资源：从<strong>其他进程</strong>剥夺足够数量的资源给死锁进程，以解除死锁</li>
<li>撤销进程</li>
</ul>
</li>
</ol>
<h1 id="第四章-存储器"><a href="#第四章-存储器" class="headerlink" title="第四章 存储器"></a>第四章 存储器</h1><h2 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h2><p><img src="assets/1544622419164.png" alt="计算机系统存储层次示意"></p>
<h2 id="程序的装入与链接"><a href="#程序的装入与链接" class="headerlink" title="程序的装入与链接"></a>程序的装入与链接</h2><ul>
<li>编译：由编译程序将用户源代码编译成若干个目标模块</li>
<li>链接：由链接程序将编译后形成的一组目标模块，以及它们所需的库函数链接在一起，形成一个完整的装入模块</li>
<li>装入：由装入程序将装入模块装入内存</li>
</ul>
<ol>
<li>程序的装入方式<ul>
<li>绝对装入方式</li>
<li>可重定位装入方式</li>
<li>动态运行时装入方式</li>
</ul>
</li>
<li>程序的链接<ul>
<li>静态链接：程序运行前</li>
<li>装入时动态链接：装入内存时</li>
<li>运行时动态链接：程序执行需要该模块时</li>
</ul>
</li>
</ol>
<h2 id="连续分配存储管理方式"><a href="#连续分配存储管理方式" class="headerlink" title="连续分配存储管理方式"></a>连续分配存储管理方式</h2><ol>
<li>单一连续分配</li>
<li>固定分区分配<ul>
<li>分区方法：分区大小相等、分区大小不等</li>
<li>内存分配</li>
</ul>
</li>
<li>动态分区分配</li>
<li>动态可重定位分区分配</li>
</ol>
<h2 id="对换Swapping"><a href="#对换Swapping" class="headerlink" title="对换Swapping"></a>对换Swapping</h2><p>将内存中暂时不能运行的进程或者暂时不用的程序和数据调出到外存上，以腾出足够的内存空间，再将已具备运行条件的进程或进程所需的程序和数据调入内存</p>
<h2 id="分页存储管理方式"><a href="#分页存储管理方式" class="headerlink" title="分页存储管理方式"></a>分页存储管理方式</h2><ul>
<li>分页存储管理：逻辑页大小=物理块大小</li>
<li>分段存储管理：逻辑性强，物理性若</li>
<li>段页式存储管理：段中有页</li>
</ul>
<ol>
<li>基本方法<ul>
<li>页面：将一个进程的逻辑地址空间分成若干大小相等的片</li>
<li>物理块/页框：把内存空间分成与页面大小相等的若干个存储块</li>
</ul>
</li>
<li>地址变换机构<ul>
<li>基本的地址变换机构</li>
<li>具有块表的地址变换机构</li>
</ul>
</li>
<li>两级和多级页表</li>
</ol>
<h2 id="分段存储管理方式"><a href="#分段存储管理方式" class="headerlink" title="分段存储管理方式"></a>分段存储管理方式</h2><h1 id="第五章虚拟存储器"><a href="#第五章虚拟存储器" class="headerlink" title="第五章虚拟存储器"></a>第五章虚拟存储器</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="常规存储器管理方式特征"><a href="#常规存储器管理方式特征" class="headerlink" title="常规存储器管理方式特征"></a>常规存储器管理方式特征</h3><ol>
<li>一次性</li>
<li>驻留性</li>
</ol>
<h3 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h3><ol>
<li>程序执行时，除了少部分的转移和过程调用指令外，在大多数情况下仍是顺序执行的</li>
<li>过程调用将会使程序的执行轨迹由一部分区域转至另一部分区域，但过程调用的深度大多数情况下不超过5，即程序在一段时间内都局限在这些过程内执行</li>
<li>程序中存在许多循环结构</li>
<li>程序包括许多对数据结构的处理<ul>
<li>局部性还表现在<strong>时间局限性</strong>和<strong>空间局限性</strong></li>
</ul>
</li>
</ol>
<h3 id="虚拟存储器的定义和特征"><a href="#虚拟存储器的定义和特征" class="headerlink" title="虚拟存储器的定义和特征"></a>虚拟存储器的定义和特征</h3><ul>
<li>虚拟存储器是指具有<strong>请求</strong>和<strong>置换</strong>功能，能从<strong>逻辑</strong>上对内存容量加以扩充的一种存储系统</li>
<li>其逻辑容量由内存容量和外存容量之和决定，运行速度接近于内存速度，而每位的成本接近于外存</li>
<li>特征<ol>
<li>多次性：指一个作业被分成多次调入内存</li>
<li>对换性：允许在作业的运行过程中进行换进、换出</li>
<li>虚拟性：从逻辑上扩充内容容量</li>
</ol>
</li>
</ul>
<h2 id="请求分页管理方式"><a href="#请求分页管理方式" class="headerlink" title="请求分页管理方式"></a>请求分页管理方式</h2><h3 id="硬件支持"><a href="#硬件支持" class="headerlink" title="硬件支持"></a>硬件支持</h3><ol>
<li><p>请求分页的页表机制</p>
</li>
<li><p>缺页中断机构</p>
</li>
<li><p>地址变换机构</p>
<p><img src="assets/1545309507999.png" alt="地址变换机构"></p>
</li>
</ol>
<h3 id="实现请求分页的软件"><a href="#实现请求分页的软件" class="headerlink" title="实现请求分页的软件"></a>实现请求分页的软件</h3><ul>
<li>实现<strong>请求调页</strong>的软件和实现<strong>页面置换</strong>的软件</li>
<li>最小物理块数：保证进程正常运行所需的最小物理块数，少于此值时，进程将无法运行</li>
</ul>
<ol>
<li>物理块分配策略<ul>
<li>固定分配局部置换</li>
<li>可变分配全局置换</li>
<li>可变分配局部置换</li>
</ul>
</li>
<li>物理块分配算法<ul>
<li>平均分配算法</li>
<li>按比例分配算法</li>
<li>考虑优先权的分配算法</li>
</ul>
</li>
<li>调页策略<ul>
<li>预调页策略</li>
<li>请求调页策略</li>
</ul>
</li>
</ol>
<h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><ol>
<li>最佳置换算法</li>
<li>先进先出置换算法</li>
<li>最近最久未使用算法（LRU）</li>
</ol>
<h2 id="“抖动”与工作集"><a href="#“抖动”与工作集" class="headerlink" title="“抖动”与工作集"></a>“抖动”与工作集</h2><h2 id="请求分段存储管理方式"><a href="#请求分段存储管理方式" class="headerlink" title="请求分段存储管理方式"></a>请求分段存储管理方式</h2><h3 id="硬件支持-1"><a href="#硬件支持-1" class="headerlink" title="硬件支持"></a>硬件支持</h3><ol>
<li><p>请求分段的段表机制</p>
</li>
<li><p>缺段中断机构</p>
<p><img src="assets/1545309589359.png" alt="请求分段系统中的中断处理过程"></p>
</li>
</ol>
<h1 id="第六章-输入输出"><a href="#第六章-输入输出" class="headerlink" title="第六章 输入输出"></a>第六章 输入输出</h1><h2 id="I-O系统的功能、模型和接口"><a href="#I-O系统的功能、模型和接口" class="headerlink" title="I/O系统的功能、模型和接口"></a>I/O系统的功能、模型和接口</h2><ul>
<li>管理的主要对象是<strong>I/O设备和相应的设备控制器</strong></li>
<li>最主要的任务是：<ul>
<li>完成用户提出的I/O请求</li>
<li>提高I/O速率</li>
<li>提高设备的利用率</li>
<li>为更高层的进程方便地使用这些设备提供手段</li>
</ul>
</li>
</ul>
<h3 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h3><ol>
<li>隐藏物理设备的细节</li>
<li>与设备无关性</li>
<li>提高处理机和I/O设备的利用率</li>
<li>对I/O设备进行控制</li>
<li>确保对设备的正常共享</li>
<li>错误处理</li>
</ol>
<h3 id="层次结构模型"><a href="#层次结构模型" class="headerlink" title="层次结构模型"></a>层次结构模型</h3><ol>
<li><p>层次结构</p>
<p><img src="assets/1545312476159.png" alt="层次结构"></p>
</li>
</ol>
<h2 id="I-O设备和设备控制器"><a href="#I-O设备和设备控制器" class="headerlink" title="I/O设备和设备控制器"></a>I/O设备和设备控制器</h2><ol>
<li><p>I/O 设备的类型</p>
<ul>
<li>按使用特性：存储设备 输出输出设备</li>
<li>按传输速率：低俗设备；中速设备；高速设备</li>
<li>按信息交换单元：块设备；字符设备</li>
<li>按共享属性：独占设备；共享设备；虚拟设备</li>
</ul>
</li>
<li><p>设备与控制器之间的接口<img src="assets/1545312780653.png" alt="1545312780653"></p>
</li>
<li><p>设备控制器的基本功能</p>
<ul>
<li>接收和识别命令</li>
<li>数据交换</li>
<li>标识和报告设备的状态</li>
<li>地址识别</li>
<li>数据缓存区</li>
<li>差错处理</li>
</ul>
</li>
<li><p>设备控制器的组成</p>
<ul>
<li><p>设备控制器与处理器的接口</p>
</li>
<li><p>设备控制器与设备的接口</p>
</li>
<li><p>I/O逻辑</p>
<p><img src="assets/1545313026687.png" alt="1545313026687"></p>
</li>
</ul>
</li>
<li><p>I/O通道</p>
<ul>
<li>字节多路通道</li>
<li>数组选择通道</li>
<li>数组多路通道</li>
</ul>
</li>
</ol>
<h2 id="中断机构和中断处理程序"><a href="#中断机构和中断处理程序" class="headerlink" title="中断机构和中断处理程序"></a>中断机构和中断处理程序</h2><h3 id="I-O控制方式"><a href="#I-O控制方式" class="headerlink" title="I/O控制方式"></a>I/O控制方式</h3><ol>
<li>程序I/O方式</li>
<li>中断驱动I/O控制方式</li>
<li>直接存储器访问I/O控制方式（DMA）</li>
<li>I/O通道控制方式</li>
</ol>
<h2 id="设备驱动程序"><a href="#设备驱动程序" class="headerlink" title="设备驱动程序"></a>设备驱动程序</h2><ul>
<li>设备驱动程序，又称设备处理程序，是I/O进程与设备控制器之间的通信程序</li>
<li>主要任务是接收上层软件发来的抽象I/O请求，将其转化为具体要求后发给设备控制器</li>
</ul>
<h3 id="设备驱动程序的功能"><a href="#设备驱动程序的功能" class="headerlink" title="设备驱动程序的功能"></a>设备驱动程序的功能</h3><ol>
<li>接收由设备独立性软件发来的命令和参数，并将命令中的抽象要求转化为具体要求</li>
<li>检查用户I/O请求的合法性，了解I/O设备的状态，传递有关参数，设置设备的工作方式</li>
<li>发出I/O命令。如设备空闲，便立即启动I/O设备去完成指定的I/O操作；如设备忙碌，则将请求者的请求挂在设备队列上等待</li>
<li>及时响应由控制器或通道发来的中断请求，并根据器中断类型调用相应的中断处理程序进行处理</li>
<li>对于设置有通道的计算机系统，驱动程序还应根据用户的I/O请求，自动地构成通道程序</li>
</ol>
<h3 id="设备处理方式"><a href="#设备处理方式" class="headerlink" title="设备处理方式"></a>设备处理方式</h3><ol>
<li>为每一类设备设置一个进程，专门用于执行这类设备的I/O操作</li>
<li>在整个系统中设置一个I/O进程，专门用于执行系统中所有各类设备的I/O操作</li>
<li>不设置专门的设备处理进程，而只为各类设备设置相应的设备处理程序，供用户进程或系统进程调用</li>
</ol>
<h3 id="设备驱动程序的特点"><a href="#设备驱动程序的特点" class="headerlink" title="设备驱动程序的特点"></a>设备驱动程序的特点</h3><ol>
<li>设备驱动程序主要是指在请求I/O的进程与设备控制器之间的一个转换程序。</li>
<li>驱动程序与设备控制器和I/O设备的硬件特性紧密相关，因而对不同类型的设备应配置不同的驱动程序</li>
<li>驱动程序与I/O设备所采用的I/O控制方式紧密相关，</li>
<li>由于驱动程序与硬件紧密相关，因而其中的一部分必须用汇编语言书写</li>
<li>驱动程序应允许重入</li>
</ol>
<h3 id="设备驱动程序的处理过程"><a href="#设备驱动程序的处理过程" class="headerlink" title="设备驱动程序的处理过程"></a>设备驱动程序的处理过程</h3><ol>
<li>将抽象要求转化为具体要求</li>
<li>检查I/O 设备的合法性</li>
<li>读出和检查设备的状态</li>
<li>传送必要的参数</li>
<li>工作方式的设置</li>
<li>启动I/O设备</li>
</ol>
<h2 id="与设备无关的I-O软件"><a href="#与设备无关的I-O软件" class="headerlink" title="与设备无关的I/O软件"></a>与设备无关的I/O软件</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ol>
<li>以物理设备名使用设备</li>
<li>引入了逻辑设备名</li>
<li>逻辑设备名称到物理设备名称的转换</li>
</ol>
<p>##用户层的I/O软件</p>
<h3 id="Spooling（假脱机）"><a href="#Spooling（假脱机）" class="headerlink" title="Spooling（假脱机）"></a>Spooling（假脱机）</h3><p>spooling的组成</p>
<ol>
<li>输入井和输出井</li>
<li>输入缓冲区和输出缓冲区</li>
<li>输入进程和输出进程</li>
<li>井管理程序</li>
</ol>
<p>spooling的特点：</p>
<ul>
<li>提高了I/O的速度</li>
<li>将独占设备改造成共享设备</li>
<li>实现了虚拟设备功能</li>
</ul>
<h2 id="缓存区管理"><a href="#缓存区管理" class="headerlink" title="缓存区管理"></a>缓存区管理</h2><h3 id="引入缓存区的原因"><a href="#引入缓存区的原因" class="headerlink" title="引入缓存区的原因"></a>引入缓存区的原因</h3><ul>
<li>缓和CPU和I/O设备间速度不匹配的矛盾</li>
<li>减少对CPU的中断频率，放宽对CPU中断响应的限制</li>
<li>解决数据粒度不匹配的问题</li>
<li>提高CPU和I/O设备之间的并行性</li>
</ul>
<h3 id="缓存池"><a href="#缓存池" class="headerlink" title="缓存池"></a>缓存池</h3><p>组成</p>
<ul>
<li>空白缓冲队列</li>
<li>输入队列</li>
<li>输出队列</li>
<li>工作缓冲区：用于收容输入数据的工作缓冲区，用于提取输入数据的工作缓冲区、用于收容输出数据的工作缓冲区、用于提取输出数据的工作缓冲区</li>
</ul>
<p>工作方式</p>
<ul>
<li>收容输入</li>
<li>提取输入</li>
<li>收容输出</li>
<li>提取输出</li>
</ul>
<h2 id="磁盘存储器的性能和调度"><a href="#磁盘存储器的性能和调度" class="headerlink" title="磁盘存储器的性能和调度"></a>磁盘存储器的性能和调度</h2><h3 id="磁盘访问时间"><a href="#磁盘访问时间" class="headerlink" title="磁盘访问时间"></a>磁盘访问时间</h3><ol>
<li>寻道时间</li>
<li>旋转延迟时间</li>
<li>传输时间</li>
</ol>
<h3 id="早期磁盘调度算法"><a href="#早期磁盘调度算法" class="headerlink" title="早期磁盘调度算法"></a>早期磁盘调度算法</h3><ol>
<li>先来先服务（FCFS）</li>
<li>最短寻道时间优先（SSTF）</li>
</ol>
<h3 id="基于扫描的磁盘调度算法"><a href="#基于扫描的磁盘调度算法" class="headerlink" title="基于扫描的磁盘调度算法"></a>基于扫描的磁盘调度算法</h3><ol>
<li>扫描算法（SCAN）</li>
<li>循环扫描算法（CSCAN）</li>
<li>NStepSCAN算法</li>
<li>FSCAN算法</li>
</ol>
<h1 id="第七章-文件管理"><a href="#第七章-文件管理" class="headerlink" title="第七章 文件管理"></a>第七章 文件管理</h1><h2 id="数据组成"><a href="#数据组成" class="headerlink" title="数据组成"></a>数据组成</h2><ol>
<li>数据项<ul>
<li>数据项是最低级的数据组织形式</li>
<li>可分为：基本数据项和组合数据项</li>
</ul>
</li>
<li>记录<ul>
<li>一组相关数据项的集合，用于描述对象在某些方面的属性</li>
<li><strong>关键字</strong>：唯一能标识一个记录的数据项</li>
</ul>
</li>
<li>文件<ul>
<li>由创建者所定义的、具有文件名的一组相关元素的集合，可分为有结构文件和无结构文件</li>
<li>文件是文件系统中一个最大的数据单位</li>
<li>文件属性包括：文件类型、文件的物理位置、文件长度、文件的建立时间</li>
</ul>
</li>
</ol>
<h3 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h3><ol>
<li>按用途分类<ul>
<li>系统文件</li>
<li>用户文件</li>
<li>库文件</li>
</ul>
</li>
<li>按文件中数据的形式分类<ul>
<li>源文件</li>
<li>目标文件</li>
<li>可执行文件</li>
</ul>
</li>
<li>按存取控制属性分类<ul>
<li>只执行文件</li>
<li>只读文件</li>
<li>读写文件</li>
</ul>
</li>
<li>按组织形式和处理方式分类<ul>
<li>普通文件</li>
<li>目录文件</li>
<li>特殊文件</li>
</ul>
</li>
</ol>
<h3 id="层次结构"><a href="#层次结构" class="headerlink" title="层次结构"></a>层次结构</h3><p><img src="assets/1545393642522.png" alt="文件系统模型"></p>
<ol>
<li>对象及其属性：文件、目录、磁盘</li>
<li>对对象操纵和管理的软件集合：<ul>
<li>对文件存储空间的管理</li>
<li>对文件目录的管理</li>
<li>用于将文件的逻辑地址转换为物理地址的机制</li>
<li>对文件读和写的管理</li>
<li>对文件的共享和保护</li>
<li>将与文件系统相关的软件分为四个层次：I/O控制层、基本文件系统层、基本I/O管理程序、逻辑文件系统</li>
</ul>
</li>
<li>文件系统接口<ul>
<li>命令接口</li>
<li>程序接口</li>
</ul>
</li>
</ol>
<h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><ol>
<li>最基本文件操作<ul>
<li>创建文件</li>
<li>删除文件</li>
<li>写文件</li>
<li>设置文件的读写位置</li>
</ul>
</li>
</ol>
<h2 id="文件的逻辑结构"><a href="#文件的逻辑结构" class="headerlink" title="文件的逻辑结构"></a>文件的逻辑结构</h2><h3 id="文件的类型"><a href="#文件的类型" class="headerlink" title="文件的类型"></a>文件的类型</h3><ol>
<li>按文件是否有结构分类<ul>
<li>有结构文件：定长记录、变长记录</li>
<li>无结构文件</li>
</ul>
</li>
<li>按文件的组织方式分类<ul>
<li>顺序文件</li>
<li>索引文件</li>
<li>索引顺序文件</li>
</ul>
</li>
</ol>
<h2 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h2><h3 id="文件控制块（FCB）"><a href="#文件控制块（FCB）" class="headerlink" title="文件控制块（FCB）"></a>文件控制块（FCB）</h3><ol>
<li>基本信息：文件名，文件物理位置，文件逻辑结构，文件的物理结构</li>
<li>存储控制信息：文件主的存取权限，核准用户的存取权限，一般用户的存取权限</li>
<li>使用信息</li>
</ol>
<h3 id="简单文件目录"><a href="#简单文件目录" class="headerlink" title="简单文件目录"></a>简单文件目录</h3><ol>
<li>单级文件目录</li>
<li>两级文件目录</li>
</ol>
<h3 id="树形结构目录"><a href="#树形结构目录" class="headerlink" title="树形结构目录"></a>树形结构目录</h3><ol>
<li>树形目录</li>
<li>路径名和当前目录</li>
</ol>
<h2 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h2><ol>
<li>基于有向无循环图实现文件共享</li>
<li>利用符号链接来实现文件共享</li>
</ol>
<h2 id="文件保护"><a href="#文件保护" class="headerlink" title="文件保护"></a>文件保护</h2><ol>
<li>保护域</li>
<li>访问矩阵8</li>
</ol>
<h1 id="第八章-磁盘存储器的管理"><a href="#第八章-磁盘存储器的管理" class="headerlink" title="第八章 磁盘存储器的管理"></a>第八章 磁盘存储器的管理</h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/18/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yezh">
      <meta itemprop="description" content="what's you problem">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yezh's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/07/18/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">go语言学习笔记</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-07-18 18:42:50" itemprop="dateCreated datePublished" datetime="2019-07-18T18:42:50+08:00">2019-07-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-13 17:26:07" itemprop="dateModified" datetime="2020-03-13T17:26:07+08:00">2020-03-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">go语言</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="go-学习笔记"><a href="#go-学习笔记" class="headerlink" title="go 学习笔记"></a>go 学习笔记</h1><h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><p>Go使用<code>package</code>将源文件打包成包，main函数所在的文件必须打包成main，编译器才会将其编译为可执行文件，否则将其编译为包。</p>
<p>导入包时，使用<code>import</code>语句，GO语言要求导入的包必须是被使用的包，若导入包未被使用，编译器会直接报错，无法通过。</p>
<p>导入包时，程序会首先运行包里面的<code>init</code>函数，当我们只需要执行<code>init</code>函数，而暂时不引用包的变量或函数时，可以使用匿名导入的方式，防止编译器报错，匿名导入只需要在包名的前面加入<code>_</code>即可，如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="string">"fmt"</span></span><br></pre></td></tr></table></figure>

<p>包的成员的外部可见性与成员的名称的大小写有关，当成员名称首字母为大写时，则该成员时导出的，引用该包的其他包可以访问这个成员；否则该成员未导出。</p>
<h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><p>Go语言不需要在语句或者声明的末尾添加分号，除非一行上有多条语句。实际上，编译器会主动把特定符号后的换行符转换为分号, 因此换行符添加的位置会影响Go代码的正确解析</p>
<ol>
<li>函数的左括号必须位于函数名之后，且在行尾，不能独占一行，（其他相似情况下类似）</li>
<li>表达式x+y中，可以在+之后换行，不能在+之前换行</li>
</ol>
<p>c类语言中i++为表达式，而go中，i++是语句而非表达式，且++i非法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*p++   <span class="comment">//增加p指针指向的变量的值，而不改变p自身，与c/c++不同</span></span><br></pre></td></tr></table></figure>

<h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h3><p>go的条件语句结构如下所示</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 语句;布尔表达式&#123;</span><br><span class="line"> 	语句   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与其他类c语言不同的是，go中的if语句不需要<code>()</code>但必须带有<code>{}</code>.同时在布尔表达式之前可以插入语句用于声明局部变量或给变量赋值等。</p>
<h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><p>go中的循环语句相关的关键字只有<code>for</code>，与if语句相同，for语句不需要<code>()</code>但必须包含<code>{}</code>,for语句一般结构如下所示</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 语句<span class="number">1</span>;布尔表达式;语句<span class="number">2</span>&#123;</span><br><span class="line">	...    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与c语言的for循环类似，同样包括三部分语句，且部分语句可以省略</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">	fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; &#123;</span><br><span class="line">	fmt.Println(i)</span><br><span class="line">	i++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> j <span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> ; j &lt; <span class="number">10</span>; j++ &#123;</span><br><span class="line">	fmt.Println(j)</span><br><span class="line">&#125;</span><br><span class="line">j = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> j == <span class="number">10</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"break frome  for1"</span>)</span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line">	&#125;</span><br><span class="line">	j++</span><br><span class="line">&#125;</span><br><span class="line">j = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> j &lt; <span class="number">10</span> &#123;</span><br><span class="line">	fmt.Print(j)</span><br><span class="line">	j++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当for后面不接任何子语句时，该for语句为死循环。当for后面只含有布尔表达式时，可以将前后的分隔符省略。</p>
<p>for语句经常搭配<code>range</code>使用，<code>range</code>用于slice或map等类似于其他语言中的迭代器的时成分</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s :=<span class="string">"hello word"</span></span><br><span class="line"><span class="keyword">var</span> a []<span class="keyword">int</span> = []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i,j := <span class="keyword">range</span>(s)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> k,v:= <span class="keyword">range</span>(a)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h2><p>不同类型间不能进行直接赋值操作</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组长度是数组类型的一部分，<code>[3]int</code>和<code>[4]int</code>属于不同类型</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">p = [<span class="number">4</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;    <span class="comment">//error</span></span><br></pre></td></tr></table></figure>

<p>与其他语言不同，go<strong>函数的数组形参包采用副本的形式传入</strong>，如果要对数组本身进行修改，需要使用指针形参，或者使用<code>slice</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(a [4]<span class="keyword">int</span>)</span>[4]<span class="title">int</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> i,j := <span class="keyword">range</span> a&#123;</span><br><span class="line">		a[i] = j+<span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a = [<span class="number">4</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;</span><br><span class="line">	fmt.Println(a)       <span class="comment">//1，2，3，4</span></span><br><span class="line">	<span class="keyword">var</span> b = test(a)</span><br><span class="line">	fmt.Println(a)      <span class="comment">//1,2,3,4</span></span><br><span class="line">	fmt.Println(b)      <span class="comment">//2,3,4,5</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h3><p>slice行为与数组类似，其底层包含一个数组，相较于数组，slice更加灵活，其长度可以动态改变，且作为函数参数时，其传递方式类似于引用，即被调函数内部的修改可以影响到主函数中的slice。</p>
<p> 切片声明时不需要指定大小，系统自动生成</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;       <span class="comment">//与数组不同，不需要指定大小</span></span><br></pre></td></tr></table></figure>

<p>值为<code>nil</code>的slice没有底层数组，与nil相等的slice长度为0，当长度为0的slice不一定是nil</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="keyword">int</span> <span class="comment">// len(s) == 0, s == nil</span></span><br><span class="line">s = <span class="literal">nil</span> <span class="comment">// len(s) == 0, s == nil</span></span><br><span class="line">s = []<span class="keyword">int</span>(<span class="literal">nil</span>) <span class="comment">// len(s) == 0, s == nil</span></span><br><span class="line">s = []<span class="keyword">int</span>&#123;&#125; <span class="comment">// len(s) == 0, s != nil</span></span><br></pre></td></tr></table></figure>

<p>内置的make函数创建一个指定元素类型、长度和容量的slice。容量部分可以省略，在这种情况下，容量将等于长度。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>([]T, <span class="built_in">len</span>)</span><br><span class="line"><span class="built_in">make</span>([]T, <span class="built_in">len</span>, <span class="built_in">cap</span>) <span class="comment">// same as make([]T, cap)[:len]</span></span><br></pre></td></tr></table></figure>

<p>内置的append函数用于向slice追加元素：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> runes []<span class="keyword">rune</span></span><br><span class="line"><span class="keyword">for</span> _, r := <span class="keyword">range</span> <span class="string">"Hello, 世界"</span> &#123;</span><br><span class="line">runes = <span class="built_in">append</span>(runes, r)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%q\n"</span>, runes) <span class="comment">// "['H' 'e' 'l' 'l' 'o' ',' ' ' '世' '界']"</span></span><br></pre></td></tr></table></figure>

<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>结构体一般格式</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> name <span class="keyword">struct</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个结构体可能同时含有导出成员和未导出成员</p>
<p>点操作符也可以和指向结构体的指针一起工作：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> employeeOfTheMonth *Employee = &amp;dilbert</span><br><span class="line">employeeOfTheMonth.Position += <span class="string">" (proactive team player)"</span></span><br></pre></td></tr></table></figure>

<p>相当于下面语句</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*employeeOfTheMonth).Position += <span class="string">" (proactive team player)"</span></span><br></pre></td></tr></table></figure>

<h4 id="结构体比较"><a href="#结构体比较" class="headerlink" title="结构体比较"></a>结构体比较</h4><p>若结构的所有成员都是可比较的，则结构体是可比较的当结构体所有成员都相等时，结构体变量相等</p>
<h4 id="嵌入和匿名"><a href="#嵌入和匿名" class="headerlink" title="嵌入和匿名"></a>嵌入和匿名</h4><ul>
<li><p>结构体可以嵌入到另一个结构体中</p>
</li>
<li><p>匿名成员的数据类型必须是命名的类型或指向一个命名的类型的指针</p>
</li>
<li><p>对于匿名嵌入，可以直接访问叶子属性而不需要给出完整的路径</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span> &#123;</span><br><span class="line">X, Y <span class="keyword">int</span></span><br><span class="line">&#125;  <span class="keyword">type</span> Circle <span class="keyword">struct</span> &#123;</span><br><span class="line">Point</span><br><span class="line">Radius <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Wheel <span class="keyword">struct</span> &#123;</span><br><span class="line">Circle</span><br><span class="line">Spokes <span class="keyword">int</span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">var</span> w Wheel</span><br><span class="line">w.X = <span class="number">8</span> <span class="comment">// equivalent to w.Circle.Point.X = 8</span></span><br><span class="line">w.Y = <span class="number">8</span> <span class="comment">// equivalent to w.Circle.Point.Y = 8</span></span><br><span class="line">w.Radius = <span class="number">5</span> <span class="comment">// equivalent to w.Circle.Radius = 5</span></span><br><span class="line">w.Spokes = <span class="number">20</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>函数声明包括函数名、形式参数列表、返回值列表（可省略）以及函数体。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">name</span><span class="params">(parameter-list)</span><span class="params">(result-list)</span></span>&#123;			    	</span><br><span class="line">    body </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下4中声明所代表的含义相同</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x <span class="keyword">int</span>, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;<span class="keyword">return</span> x + y&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sub</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="params">(z <span class="keyword">int</span>)</span></span> &#123; z = x - y; <span class="keyword">return</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">first</span><span class="params">(x <span class="keyword">int</span>, _ <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> x &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">zero</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;</span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>, add) <span class="comment">// "func(int, int) int"</span></span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>, sub) <span class="comment">// "func(int, int) int"</span></span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>, first) <span class="comment">// "func(int, int) int"</span></span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>, zero) <span class="comment">// "func(int, int) int"</span></span><br></pre></td></tr></table></figure>

<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>go支持多个返回值</p>
<p>如果一个函数将所有的返回值都显示的变量名，那么该函数的return语句可以省略操作数。这<br>称之为bare return。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CountWordsAndImages does an HTTP GET request for the HTML</span></span><br><span class="line"><span class="comment">// document url and returns the number of words and images in it.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CountWordsAndImages</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="params">(words, images <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">resp, err := http.Get(url)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">doc, err := html.Parse(resp.Body)</span><br><span class="line">resp.Body.Close()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">err = fmt.Errorf(<span class="string">"parsing HTML: %s"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">words, images = countWordsAndImages(doc)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countWordsAndImages</span><span class="params">(n *html.Node)</span> <span class="params">(words, images <span class="keyword">int</span>)</span></span> &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数值"><a href="#函数值" class="headerlink" title="函数值"></a>函数值</h3><p>在GO中，函数被看作第一类值：函数拥有类型，可以赋值给其他变量，传递给函数，从函数返回，但是函数值之间是不可比较的，也不能用函数值作为map的key。</p>
<h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>拥有函数名的函数只能在包级语法块中被声明，通过函数字面量（function    literal），我们可绕过这一限制，在任何表达式中表示一个函数值。函数字面量的语法和函数声明相似，区别 在于func关键字后没有函数名。函数值字面量是一种表达式，它的值被称为匿名函数（anonymous    function）。通过这种方式定义的函数可以访问完整的词法环境（lexical    environment）， 这意味着在函数中定义的内部函数可以引用该函数的变量，如下例所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// squares返回一个匿名函数。</span></span><br><span class="line"><span class="comment">// 该匿名函数每次被调用时都会返回下一个数的平方。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">squares</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        x++</span><br><span class="line">        <span class="keyword">return</span> x * x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">f := squares()</span><br><span class="line">fmt.Println(f()) <span class="comment">// "1"</span></span><br><span class="line">fmt.Println(f()) <span class="comment">// "4"</span></span><br><span class="line">fmt.Println(f()) <span class="comment">// "9"</span></span><br><span class="line">fmt.Println(f()) <span class="comment">// "16"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数squares返回另一个类型为 func() int 的函数。对squares的一次调用会生成一个局部变量x并返回一个匿名函数。每次调用时匿名函数时，该函数都会先使x的值加1，再返回x的平方。第二次调用squares时，会生成第二个x变量，并返回一个新的匿名函数。新匿名函数操作的是第二个x变量。</p>
<h3 id="注意捕获迭代变量"><a href="#注意捕获迭代变量" class="headerlink" title="注意捕获迭代变量"></a>注意捕获迭代变量</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rmdirs []<span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">for</span> _, d := <span class="keyword">range</span> tempDirs() &#123;</span><br><span class="line">    dir := d <span class="comment">// <span class="doctag">NOTE:</span> necessary!</span></span><br><span class="line">    os.MkdirAll(dir, <span class="number">0755</span>) <span class="comment">// creates parent directories too</span></span><br><span class="line">    rmdirs = <span class="built_in">append</span>(rmdirs, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    os.RemoveAll(dir)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...do some work…</span></span><br><span class="line"><span class="keyword">for</span> _, rmdir := <span class="keyword">range</span> rmdirs &#123;</span><br><span class="line">	rmdir() <span class="comment">// clean up</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的程序中，for循环语句引入了新的词法块，循环 变量dir在这个词法块中被声明。在该循环中生成的所有函数值都共享相同的循环变量。需要注意，函数值中记录的是循环变量的内存地址，而不是循环变量某一时刻的值。以dir为例， 后续的迭代会不断更新dir的值，当删除操作执行时，for循环已完成，dir中存储的值等于最后一次迭代的值。这意味着，每次对os.RemoveAll的调用删除的都是相同的目录。这不是go或defer本身导致的，而是因为<strong>它们都会等待循环结束后，再执行函数值。</strong><br>通常，为了解决这个问题，我们会引入一个与循环变量同名的局部变量，作为循环变量的副 本。比如下面的变量dir，虽然这看起来很奇怪，但却很有用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span></span><br><span class="line">_, dir := <span class="keyword">range</span> tempDirs() &#123;</span><br><span class="line">dir := dir <span class="comment">// declares inner dir, initialized to outer dir</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>参数数量可变的函数称为为可变参数函数。典型的例子就是fmt.Printf和类似函数。Printf首先接收一个的必备参数，之后接收任意个数的后续参数。在声明可变参数函数时，需要在参数列表的最后一个参数类型之前加上省略符号“…”，这表示<br>该函数会接收任意数量的该类型参数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(vals...<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    total := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, val := <span class="keyword">range</span> vals &#123;</span><br><span class="line">        total += val</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sum函数返回任意个int型参数的和。在函数体中,vals被看作是类型为[] int的切片。sum可以接收任意数量的int型参数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(sum()) <span class="comment">// "0"</span></span><br><span class="line">fmt.Println(sum(<span class="number">3</span>)) <span class="comment">// "3"</span></span><br><span class="line">fmt.Println(sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)) <span class="comment">// "10"</span></span><br></pre></td></tr></table></figure>

<p>在上面的代码中，调用者隐式的创建一个数组，并将原始参数复制到数组中，再把数组的一个切片作为参数传给被调函数。如果原始参数已经是切片类型，我们该如何传递给sum？只需在最后一个参数后加上省略符。下面的代码功能与上个例子中最后一条语句相同。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">values := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">fmt.Println(sum(values...)) <span class="comment">// "10"</span></span><br></pre></td></tr></table></figure>

<p>虽然在可变参数函数内部，…int 型参数的行为看起来很像切片类型，但实际上，可变参数函数和以切片作为参数的函数是不同的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(...<span class="keyword">int</span>)</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">g</span><span class="params">([]<span class="keyword">int</span>)</span></span> &#123;&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>, f) <span class="comment">// "func(...int)"</span></span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>, g) <span class="comment">// "func([]int)"</span></span><br></pre></td></tr></table></figure>

<h3 id="Deferred函数"><a href="#Deferred函数" class="headerlink" title="Deferred函数"></a>Deferred函数</h3><p>当defer语句被执行时，跟在defer后面的函数会被延迟执行。直到包含该defer语句的函数执行完毕时，defer后的函数才会被执行，不论包含defer语句的函数是通过return正常结束，还是由于panic导致的异常结束。你可以在一个函数中执行多条defer语句，它们的执行顺序与声明顺序相反。</p>
<p>defer语句经常被用于处理成对的操作，如打开、关闭、连接、断开连接、加锁、释放锁。通过defer机制，不论函数逻辑多复杂，都能保证在任何执行路径下，资源被释放。释放资源的defer应该直接跟在请求资源的语句后。</p>
<h3 id="Panic"><a href="#Panic" class="headerlink" title="Panic"></a>Panic</h3><p>Go的类型系统会在编译时捕获很多错误，但有些错误只能在运行时检查，如数组访问越界、空指针引用等。这些运行时错误会引起painc异常。<br>一般而言，当panic异常发生时，程序会中断运行，并立即执行在该goroutine中被延迟的函数（defer 机制）。随后，程序崩溃并输出日志信息。日志信息包括panic value和函数调用的堆栈跟踪信息。panic value通常是某种错误信息。对于每个goroutine，日志信息中都会有与之相对的，发生panic时的函数调用堆栈跟踪信息。通常，我们不需要再次运行程序去定位问题，日志信息已经提供了足够的诊断依据。因此，在我们填写问题报告时，一般会将panic异常和日志信息一并记录。</p>
<p>虽然Go的panic机制类似于其他语言的异常，但panic的适用场景有一些不同。由于panic会引起程序的崩溃，因此panic一般用于严重错误，如程序内部的逻辑不一致。</p>
<h3 id="Recover捕获异常"><a href="#Recover捕获异常" class="headerlink" title="Recover捕获异常"></a>Recover捕获异常</h3><p>如果在deferred函数中调用了内置函数recover，并且定义该defer语句的函数发生了panic异常，recover会使程序从panic中恢复，并返回panic value。导致panic异常的函数不会继续运行，但能正常返回。在未发生panic时调用recoverrecover会返回nil。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Parse</span><span class="params">(input <span class="keyword">string</span>)</span> <span class="params">(s *Syntax, err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> p := <span class="built_in">recover</span>(); p != <span class="literal">nil</span> &#123;</span><br><span class="line">err = fmt.Errorf(<span class="string">"internal error: %v"</span></span><br><span class="line">, p)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="comment">// ...parser...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>deferred函数帮助Parse从panic中恢复。在deferred函数内部，panic value被附加到错误信息中；并用err变量接收错误信息，返回给调用者。我们也可以通过调用runtime.Stack往错误信息中添加完整的堆栈调用信息。</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>  GO不支持类，但支持方法，可以为结构体或其他类型定义方法，方法就是一类带特殊的 <strong>接收者</strong> 参数的函数。方法接收者在它自己的参数列表内，位于 <code>func</code> 关键字和方法名之间。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">  	X, Y <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;        <span class="comment">//定义结构体方法</span></span><br><span class="line">  	<span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  	v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">      fmt.Println(v.Abs())                  <span class="comment">//v.Abs() 调用方法</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>  其形式类似于将函数声明中的形参放到函数名之前。  只能为同一个包的类型接收者声明方法，不能为其他包内定义的类型声明方法。 不能为内置类型（如：<code>int</code>）定义方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyFloat <span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f MyFloat)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;              <span class="comment">//ture</span></span><br><span class="line">	<span class="keyword">if</span> f &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">float64</span>(-f)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">float64</span>(f)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//cannot define new methods on non-local type float64</span></span><br><span class="line"><span class="comment">//func (f float64) Abs() float64 &#123;       </span></span><br><span class="line"><span class="comment">//	if f &lt; 0 &#123;</span></span><br><span class="line"><span class="comment">//		return float64(-f)</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"><span class="comment">//	return float64(f)</span></span><br><span class="line"><span class="comment">//&#125; </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	f := MyFloat(-math.Sqrt2)</span><br><span class="line">	fmt.Println(f.Abs())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="指针接收者"><a href="#指针接收者" class="headerlink" title="指针接收者"></a>指针接收者</h3><p>使用指针接收者可以改变接收者自身的值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">	X, Y <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span> <span class="title">Scale</span><span class="params">(f <span class="keyword">float64</span>)</span></span> &#123;               <span class="comment">//指针接收者</span></span><br><span class="line">	v.X = v.X * f</span><br><span class="line">	v.Y = v.Y * f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">    v.Scale(<span class="number">10</span>)                 <span class="comment">//v = &#123;30,40&#125;</span></span><br><span class="line">	fmt.Println(v.Abs())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用函数时，指针类型的形参必须接受一个指针；调用方法时接收者为变量时可以是指针也可以为值，编译器会自动解引用或取地址。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v Vertex</span><br><span class="line">ScaleFunc(v, <span class="number">5</span>)  <span class="comment">// 编译错误！</span></span><br><span class="line">ScaleFunc(&amp;v, <span class="number">5</span>) <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> v Vertex</span><br><span class="line">v.Scale(<span class="number">5</span>)  <span class="comment">// OK</span></span><br><span class="line">p := &amp;v</span><br><span class="line">p.Scale(<span class="number">10</span>) <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>

<p><em>在现实的程序里，一般会约定如果Point这个类有一个指针作为接收器的方法，那么所有Point 的方法都必须有一个指针接收器，即使是那些并不需要这个指针接收器的函数。</em></p>
<p>只有类型(Point)和指向他们的指针(<em>Point)，才是可能会出现在接收器声明里的两种接收器。 此外，为了避免歧义，在声明方法时，*</em>如果一个类型名本身是一个指针的话，是不允许其出现在接收器中的**，比如下面这个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span>	P	*<span class="keyword">int</span> </span><br><span class="line"><span class="function"><span class="keyword">func</span>	<span class="params">(P)</span>	<span class="title">f</span><span class="params">()</span></span>	&#123;	<span class="comment">/*	...	*/</span>	&#125;	<span class="comment">//	compile	error:	invalid	receiver	type</span></span><br></pre></td></tr></table></figure>

<ol>
<li>不管你的method的receiver是指针类型还是非指针类型，都是可以通过指针/非指针类型 进行调用的，编译器会帮你做类型转换。</li>
<li>在声明一个method的receiver该是指针还是非指针类型时，你需要考虑两方面的内部，第 一方面是这个对象本身是不是特别大，如果声明为非指针变量时，调用会产生一次拷贝；第二方面是如果你用指针类型作为receiver，那么你一定要注意，这种指针类型指向 的始终是一块内存地址，就算你对其进行了拷贝。熟悉C或者C艹的人这里应该很快能明 白</li>
</ol>
<h3 id="使用嵌入类型扩展类型"><a href="#使用嵌入类型扩展类型" class="headerlink" title="使用嵌入类型扩展类型"></a>使用嵌入类型扩展类型</h3><p>使用嵌入结构体时，被嵌入结构体可以直接调用嵌入结构体的方法，</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"image/color"</span></span><br><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span>&#123; X, Y <span class="keyword">float64</span> &#125;</span><br><span class="line"><span class="keyword">type</span> ColoredPoint <span class="keyword">struct</span> &#123;</span><br><span class="line">    Point</span><br><span class="line">    Color color.RGBA</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">red := color.RGBA&#123;<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>&#125;</span><br><span class="line">blue := color.RGBA&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>&#125;</span><br><span class="line"><span class="keyword">var</span> p = ColoredPoint&#123;Point&#123;<span class="number">1</span>, <span class="number">1</span>&#125;, red&#125;</span><br><span class="line"><span class="keyword">var</span> q = ColoredPoint&#123;Point&#123;<span class="number">5</span>, <span class="number">4</span>&#125;, blue&#125;</span><br><span class="line">fmt.Println(p.Distance(q.Point)) <span class="comment">// "5"   Distance是point类型的方法，p的类型为ColoredPoint，但可以直接调用Distance</span></span><br><span class="line">p.ScaleBy(<span class="number">2</span>)</span><br><span class="line">q.ScaleBy(<span class="number">2</span>)</span><br><span class="line">fmt.Println(p.Distance(q.Point)) <span class="comment">// "10" 但参数类型为Point时，必须显示调用point字段</span></span><br></pre></td></tr></table></figure>

<h3 id="方法值和方法表达式"><a href="#方法值和方法表达式" class="headerlink" title="方法值和方法表达式"></a>方法值和方法表达式</h3><p>可以将特定变量的方法调用赋值给变量，通过变量调用方法，其形式类似于函数变量的赋值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">p := Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">q := Point&#123;<span class="number">4</span>, <span class="number">6</span>&#125;</span><br><span class="line">distanceFromP := p.Distance <span class="comment">// method value，选择器返回一个方法值</span></span><br><span class="line">fmt.Println(distanceFromP(q)) <span class="comment">// "5"</span></span><br><span class="line"></span><br><span class="line">scaleP := p.ScaleBy <span class="comment">// method value，选择器返回一个方法值</span></span><br><span class="line">scaleP(<span class="number">2</span>) <span class="comment">// p becomes (2, 4)</span></span><br></pre></td></tr></table></figure>

<p><code>p.distance</code>，<code>p.ScaleBy称为</code>选择器，选择器返回一个方法值。</p>
<p>在一个包的API需要一个函数值、且调用方希望操作的是某一个绑定了对象的方法的话，方<br>法”值”会非常实用。举例来说，下面例子中的<code>time.AfterFunc</code>这个函数的功能是在指定的延迟时间之后来执行一个(译注：另外的)函数。且这个函数操作的是一个Rocket对象r</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Rocket <span class="keyword">struct</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Rocket)</span> <span class="title">Launch</span><span class="params">()</span></span> &#123; / ... */ &#125;</span><br><span class="line">r := <span class="built_in">new</span>(Rocket)</span><br><span class="line">time.AfterFunc(<span class="number">10</span> * time.Second, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; r.Launch() &#125;)      <span class="comment">//这里相当于将r.Launch封装为一个函数传入</span></span><br></pre></td></tr></table></figure>

<p>直接用方法”值”传入<code>AfterFunc</code>的话可以更为简短：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time.AfterFunc(<span class="number">10</span> * time.Second, r.Launch)</span><br></pre></td></tr></table></figure>

<p>和方法”值”相关的还有方法表达式。当调用一个方法时，与调用一个普通的函数相比，我们必须要用选择器(p.Distance)语法来指定方法的接收器。当T是一个类型时，方法表达式可能会写作T.f或者(*T).f，会返回一个函数”值”，这种函数会将<br>其第一个参数用作接收器，所以可以用通常(译注：不写选择器)的方式来对其进行调用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">p := Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">q := Point&#123;<span class="number">4</span>, <span class="number">6</span>&#125;</span><br><span class="line"><span class="comment">//这里Point是类型名，其拥有一个方法func (p Point) Distance()，</span></span><br><span class="line">distance := Point.Distance <span class="comment">// method expression </span></span><br><span class="line">fmt.Println(distance(p, q)) <span class="comment">// "5"</span></span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>, distance) <span class="comment">// "func(Point, Point) float64"</span></span><br><span class="line">scale := (*Point).ScaleBy</span><br><span class="line">scale(&amp;p, <span class="number">2</span>)</span><br><span class="line">fmt.Println(p) <span class="comment">// "&#123;2 4&#125;"</span></span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span></span><br><span class="line">, scale) <span class="comment">// "func(*Point, float64)"</span></span><br></pre></td></tr></table></figure>

<p>以上的内容相当于将类型的一个方法转化为一个函数，该函数相较于方法多了第一个参数，该参数表明接收器，如上述将方法<code>func (p Point) Distance()float64</code>转化为<code>func(Point, Point) float64</code></p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>在Go语言中还存在着另外一种类型：接口类型。接口类型是一种抽象的类型。它不会暴露出它所代表的对象的内部值的结构和这个对象支持的基础操作的集合；它们只会展示出它们自己的方法。也就是说当你有看到一个接口类型的值时，你不知道它是什么，唯一知道的就是可以通过它的方法来做什么。</p>
<p>nil 接口值既不保存值也不保存具体类型。</p>
<p>也就是说，如果一个类型声明了某个接口给出的所有方法，则认为该类型继承了该接口，而无需显式说明。</p>
<h3 id="常用内建接口"><a href="#常用内建接口" class="headerlink" title="常用内建接口"></a>常用内建接口</h3><p><code>Stringer</code> 是一个可以用字符串描述自己的类型。<code>fmt</code> 包（还有很多包）都通过此接口来打印值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">"%v (%v years)"</span>, p.Name, p.Age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := Person&#123;<span class="string">"Arthur Dent"</span>, <span class="number">42</span>&#125;</span><br><span class="line">	z := Person&#123;<span class="string">"Zaphod Beeblebrox"</span>, <span class="number">9001</span>&#125;</span><br><span class="line">	fmt.Println(a, z)  <span class="comment">//Arthur Dent (42 years) Zaphod Beeblebrox (9001 years)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="error接口"><a href="#error接口" class="headerlink" title="error接口"></a>error接口</h3><p>Go 程序使用 <code>error</code> 值来表示错误状态。与 <code>fmt.Stringer</code> 类似，<code>error</code> 类型是一个内建接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（与 <code>fmt.Stringer</code> 类似，<code>fmt</code> 包在打印值时也会满足 <code>error</code>。）</p>
<h3 id="http-Handler接口"><a href="#http-Handler接口" class="headerlink" title="http.Handler接口"></a>http.Handler接口</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> http</span><br><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">	ServeHTTP(w ResponseWriter, r *Request)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenAndServe</span><span class="params">(address <span class="keyword">string</span>, h Handler)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>

<p>ListenAndServe函数需要一个例如“localhost:8000”的服务器地址，和一个所有请求都可以分派的Handler接口实例。它会一直运行，直到这个服务因为一个错误而失败（或者启动失败），它的返回值一定是一个非空的错误。</p>
<h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p><strong>类型断言</strong> 提供了访问接口值底层具体值的方式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t :&#x3D; i.(T)</span><br></pre></td></tr></table></figure>

<p>该语句断言接口值 <code>i</code> 保存了具体类型 <code>T</code>，并将其底层类型为 <code>T</code> 的值赋予变量 <code>t</code>。若 <code>i</code> 并未保存 <code>T</code> 类型的值，该语句就会触发一个panic。</p>
<p>这里有两种可能。第一种，如果断言的类型T是一个具体类型，然后类型断言检查x的动态类型是否和T相同。如果这个检查成功了，类型断言的结果是x的动态值，当然它的类型是T。换句话说，具体类型的类型断言从它的操作对象中获得具体的值。如果检查失败，接下来这个操作会抛出panic。例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> w io.Writer</span><br><span class="line">w = os.Stdout</span><br><span class="line">f := w.(*os.File) <span class="comment">// success: f == os.Stdout</span></span><br><span class="line">c := w.(*bytes.Buffer) <span class="comment">// panic: interface holds *os.File, not *bytes.Buffer</span></span><br></pre></td></tr></table></figure>

<p>上述中，w为<code>os.Stdout</code>，其类型为<code>*os.File</code>,所以<code>w.(*os.File)</code>断言成功，返回w的动态值，即<code>os.Stdout</code>。因为w的类型与<code>*bytes.Buffer</code>不符，所以<code>c :=w.(*bytes.Buffer)</code>运行时返回panic</p>
<p>如果断言类型T是接口类型，则类型断言检查x的动态类型是否满足T.如果此检查成功，在下面代码中，<code>w.(io.ReadWriter)</code>检查的是w的动态类型(即<code>os.Stdout</code>的动态类型<code>io.ReadWriter</code>)，与w的接口<code>io.Writer</code>无关。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> w io.Writer</span><br><span class="line">w = os.Stdout</span><br><span class="line">rw := w.(io.ReadWriter) <span class="comment">// success: *os.File has both Read and Write</span></span><br><span class="line">w.Write([]<span class="keyword">byte</span>(<span class="string">"w write "</span>))</span><br><span class="line"><span class="comment">//	w.Read([]byte("w read"))   //w.Read undefined (type io.Writer has no field or method Read)</span></span><br><span class="line">rw.Read([]<span class="keyword">byte</span>(<span class="string">"rw read"</span>))</span><br><span class="line">rw.Write([]<span class="keyword">byte</span>(<span class="string">"rw write"</span>))</span><br></pre></td></tr></table></figure>

<p>在上面的第一个类型断言后，w和rw都持有<code>os.Stdout</code>因此它们每个有一个动态类型<code>*os.File</code>，但是变量w是一个<code>io.Write</code>, r类型只对外公开出文件的Write方法，然而rw变量同时公开它的Read和write方法。</p>
<p>如果断言操作的对象是一个nil接口值，那么不论被断言的类型是什么这个类型断言都会失败。</p>
<p>为了 判断 一个接口值是否保存了一个特定的类型，类型断言可返回两个值：其底层值以及一个报告断言是否成功的布尔值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t, ok :&#x3D; i.(T)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = <span class="string">"hello"</span></span><br><span class="line"></span><br><span class="line">	s := i.(<span class="keyword">string</span>)           <span class="comment">//i保存的值的具体类型为string</span></span><br><span class="line">	fmt.Println(s)</span><br><span class="line"></span><br><span class="line">	s, ok := i.(<span class="keyword">string</span>)</span><br><span class="line">	fmt.Println(s, ok)</span><br><span class="line"></span><br><span class="line">	f, ok := i.(<span class="keyword">float64</span>)</span><br><span class="line">	fmt.Println(f, ok)</span><br><span class="line"></span><br><span class="line">	f = i.(<span class="keyword">float64</span>) <span class="comment">// 报错(panic)</span></span><br><span class="line">	fmt.Println(f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类型选择"><a href="#类型选择" class="headerlink" title="类型选择"></a>类型选择</h3><p><strong>类型选择</strong> 是一种按顺序从几个类型断言中选择分支的结构。</p>
<p>类型选择与一般的 switch 语句相似，不过类型选择中的 case 为类型（而非值）， 它们针对给定接口值所存储的值的类型进行比较。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> v := i.(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">		fmt.Printf(<span class="string">"Twice %v is %v\n"</span>, v, v*<span class="number">2</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">		fmt.Printf(<span class="string">"%q is %v bytes long\n"</span>, v, <span class="built_in">len</span>(v))</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Printf(<span class="string">"I don't know about type %T!\n"</span>, v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	do(<span class="number">21</span>)</span><br><span class="line">	do(<span class="string">"hello"</span>)</span><br><span class="line">	do(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><h3 id="Goroutines"><a href="#Goroutines" class="headerlink" title="Goroutines"></a>Goroutines</h3><p>Go 程（goroutine）是由 Go 运行时管理的轻量级线程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go f(x, y, z)</span><br></pre></td></tr></table></figure>

<p>会启动一个新的 Go 程并执行</p>
<h3 id="Channels"><a href="#Channels" class="headerlink" title="Channels"></a>Channels</h3><p>信道是带有类型的管道，你可以通过它用信道操作符 <code>&lt;-</code> 来发送或者接收值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- v    <span class="comment">// 将 v 发送至信道 ch。</span></span><br><span class="line">v := &lt;-ch  <span class="comment">// 从 ch 接收值并赋予 v。</span></span><br></pre></td></tr></table></figure>

<p>（“箭头”就是数据流的方向。）</p>
<p>和映射与切片一样，信道在使用前必须创建：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">100</span>)       <span class="comment">//带缓冲信道</span></span><br></pre></td></tr></table></figure>

<p>默认情况下，发送和接收操作在另一端准备好之前都会<strong>阻塞</strong>。这使得 Go 程可以在没有显式的锁或竞态变量的情况下进行同步。         </p>
<h4 id="关闭信道"><a href="#关闭信道" class="headerlink" title="关闭信道"></a>关闭信道</h4><p>发送者可通过 <code>close(ch)</code> 关闭一个信道来表示没有需要发送的值了。接收者可以通过为接收表达式分配第二个参数来测试信道是否被关闭：若没有值可以接收且信道已被关闭，那么在执行完</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v, ok := &lt;-ch</span><br></pre></td></tr></table></figure>

<p>之后 <code>ok</code> 会被设置为 <code>false</code>值。循环 <code>for i := range c</code> 会不断从信道接收值，直到它被关闭。</p>
<p><em>注意：</em> <strong>只有发送者才能关闭信道，而接收者不能。</strong>向一个已经关闭的信道发送数据会引发程序恐慌（panic）。</p>
<p>当一个被关闭的channel中已经发送的数据都被成功接收后，后续的接收操作将不再阻塞，它们会立即返回一个零</p>
<p><em>还要注意：</em> 信道与文件不同，通常情况下无需关闭它们。只有在必须告诉接收者不再有需要发送的值时才有必要关闭，例如终止一个 <code>range</code> 循环。</p>
<h4 id="单向channel"><a href="#单向channel" class="headerlink" title="单向channel"></a>单向channel</h4><p>Go语言的类型系统提供了单方向的channel类型，分别用于只发送或只接收的<code>channel</code>。类型 <code>chan&lt;- int</code>表示一个只发送int的channel，只能发送不能接收。相反，类型<code>&lt;-chan int</code> 表示一个只接收int的channel，只能接收不能发送。（箭头 &lt;- 和关键字chan的相对位置表明了channel的方向。）这种限制将在编译期检测。</p>
<h4 id="带缓存的channel"><a href="#带缓存的channel" class="headerlink" title="带缓存的channel"></a>带缓存的channel</h4><p>带缓存的Channel内部持有一个元素队列。队列的最大容量是在调用make函数创建channel时通过第二个参数指定的。下面的语句创建了一个可以持有三个字符串元素的带缓存Channel。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>使用内置函数cap可以获取channel缓存大小, 函数len可以获取channel有效数据个数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="built_in">cap</span>(ch))     <span class="comment">//缓冲区大小</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(ch))     <span class="comment">//channel中的有效数据个数</span></span><br></pre></td></tr></table></figure>

<ul>
<li><input disabled="" type="checkbox"> <code>make(chan int)</code>和<code>make(chan int,1)</code>的区别</li>
</ul>
<h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p><code>select</code> 语句使一个 Go 程可以等待多个通信操作。</p>
<p><code>select</code> 会阻塞到某个分支可以继续执行为止，这时就会执行该分支。<strong>当多个分支都准备好时会随机选择一个执行。</strong></p>
<p>当 <code>select</code> 中的其它分支都没有准备好时，<code>default</code> 分支就会执行。为了在尝试发送或者接收时不发生阻塞，可使用 <code>default</code> 分支：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> i := &lt;-c:</span><br><span class="line">    <span class="comment">// 使用 i</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// 从 c 中接收会阻塞时执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Goroutines和线程"><a href="#Goroutines和线程" class="headerlink" title="Goroutines和线程"></a>Goroutines和线程</h3><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>每一个OS线程都有一个固定大小的内存块(一般会是2MB)来做栈，这个栈会用来存储当前正在被调用或挂起(指在调用其它函数时)的函数的内部变量。</p>
<p>相反，一个goroutine会以一个很小的栈开始其生命周期，一般只需要2KB。一个goroutine的栈，和操作系统线程一样，会保存其活跃或挂起的函数调用的本地变量，但是和OS线程不太一样的是一个goroutine的栈大小并不是固定的；栈的大小会根据需要动态地伸缩。</p>
<h3 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h3><p>OS线程由操作系统内核调用调用时会产生上下文切换，消耗资源较多</p>
<p>GO自身包含调度器，其调度消耗小于线程切换</p>
<h3 id="Goroutine没有ID号"><a href="#Goroutine没有ID号" class="headerlink" title="Goroutine没有ID号"></a>Goroutine没有ID号</h3><p>在大多数支持多线程的操作系统和程序语言中，当前的线程都有一个独特的身份(id)，并且这个身份信息可以以一个普通值的形式被被很容易地获取到，典型的可以是一个integer或者指针值。goroutine没有可以被程序员获取到的身份(id)的概念。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/18/http/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yezh">
      <meta itemprop="description" content="what's you problem">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yezh's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/07/18/http/" class="post-title-link" itemprop="url">HTTP/HTTPS协议</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-07-18 18:42:50" itemprop="dateCreated datePublished" datetime="2019-07-18T18:42:50+08:00">2019-07-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-13 17:26:07" itemprop="dateModified" datetime="2020-03-13T17:26:07+08:00">2020-03-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/http/" itemprop="url" rel="index"><span itemprop="name">http</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="HTTP-HTTPS协议"><a href="#HTTP-HTTPS协议" class="headerlink" title="HTTP/HTTPS协议"></a>HTTP/HTTPS协议</h1><h2 id="URL-URI"><a href="#URL-URI" class="headerlink" title="URL/URI"></a>URL/URI</h2><blockquote>
<p>URI 用字符串标识某一互联网资源，而 URL 表示资源的地点（互联 网上所处的位置）。可见 URL 是 URI 的子集。 </p>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//URI绝对格式</span><br><span class="line">http://user:pass@www.example.jp:80/dir/index.html?uid=1#ch1</span><br><span class="line"><span class="tag">&lt;<span class="name">-!</span>  方案名：//登录信息@服务器地址<span class="attr">:</span>端口号/文件路径?查询字符#片段标识符 &gt;</span></span><br><span class="line"></span><br><span class="line">https://blog.csdn.net/weixin_39780047/article/details/88850857</span><br><span class="line"><span class="tag">&lt;<span class="name">协议</span>&gt;</span>：//<span class="tag">&lt;<span class="name">host</span>&gt;</span>:<span class="tag">&lt;<span class="name">port</span>&gt;</span>/<span class="tag">&lt;<span class="name">路径</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><em>http默认端口是80，可省略</em></li>
<li>省略路径时，默认指向主页<h2 id="操作过程"><a href="#操作过程" class="headerlink" title="操作过程"></a>操作过程</h2></li>
</ul>
<ol>
<li>浏览器从 URL 中解析出服务器的主机名； </li>
<li>浏览器将服务器的主机名转换成服务器的 IP 地址；</li>
<li>浏览器将端口号（如果有的话）从 URL 中解析出来；</li>
<li>浏览器建立一条与 Web 服务器的 TCP 连接； </li>
<li>浏览器向服务器发送一条 HTTP 请求报文； </li>
<li>服务器向浏览器回送一条 HTTP 响应报文；</li>
<li>关闭连接，浏览器显示文档</li>
</ol>
<ul>
<li>http1.0是无状态的，每次访问数据时都要进行tcp的连接和释放。http1.1之后采用持续连接方式，tcp连接在完成请求后依然保留一段时间，可重复使用<h2 id="代理服务器"><a href="#代理服务器" class="headerlink" title="代理服务器"></a>代理服务器</h2><blockquote>
<p>代理服务器将最近的一些请求和响应暂存在本地中。当新请求到到达时，若代理服务器中包含相同资源，则返回暂存的请求响应。否则通过因特网获取请求响应并复制一份在本地(缓存服务器)</p>
</blockquote>
</li>
</ul>
<p><strong>使用代理服务器的理由</strong></p>
<blockquote>
<p>利用缓存技术（稍后讲解）减少网络带宽 的流量，组织内部针对特定网站的访问控制，以获取访问日志为主要 目的，等等。</p>
</blockquote>
<h2 id="报文结构"><a href="#报文结构" class="headerlink" title="报文结构"></a>报文结构</h2><p>http分为请求报文和响应报文</p>
<p><img src="assets/20190327172847876-1553845578881.jpg" alt="请求报文"></p>
<p><img src="assets/20190327172941876.jpg" alt="响应报文"></p>
<h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><table>
<thead>
<tr>
<th>1**</th>
<th>通知信息</th>
</tr>
</thead>
<tbody><tr>
<td>2**</td>
<td>表示成功</td>
</tr>
<tr>
<td>3**</td>
<td>重定向，还需要采取进一步行动</td>
</tr>
<tr>
<td>4**</td>
<td>客户端错误，语法错误活无法完成请求</td>
</tr>
<tr>
<td>5**</td>
<td>服务器错误，服务器在处理过程中发送生错误</td>
</tr>
</tbody></table>
<p>常见状态：</p>
<ul>
<li>202 Accepted    接受</li>
<li>400 Bad Request  错误请求</li>
<li>404 Not Found 找不到</li>
</ul>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p><img src="assets/20190327173152645.jpg" alt="方法"></p>
<h3 id="首部字段名"><a href="#首部字段名" class="headerlink" title="首部字段名"></a>首部字段名</h3><ol>
<li>通用首部字段</li>
</ol>
<table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Cache-Control</td>
<td>控制缓存的行为</td>
</tr>
<tr>
<td>Connection</td>
<td>逐跳首部、连接的管理</td>
</tr>
<tr>
<td>Date</td>
<td>创建报文的日期时间</td>
</tr>
<tr>
<td>Pragma</td>
<td>报文指令</td>
</tr>
<tr>
<td>Trailer</td>
<td>报文末端的首部一览</td>
</tr>
<tr>
<td>Transfer-Encoding</td>
<td>指定报文主体的传输编码方式</td>
</tr>
<tr>
<td>Upgrade</td>
<td>升级为其他协议</td>
</tr>
<tr>
<td>Via</td>
<td>代理服务器的相关信息</td>
</tr>
<tr>
<td>Warning</td>
<td>错误通知</td>
</tr>
</tbody></table>
<ol start="2">
<li><p>请求首部字段</p>
<table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Accept</td>
<td>用户代理可处理的媒体类型</td>
</tr>
<tr>
<td>Accept-Charset</td>
<td>优先的字符集</td>
</tr>
<tr>
<td>Accept-Encoding</td>
<td>优先的内容编码</td>
</tr>
<tr>
<td>Accept-Language</td>
<td>优先的语言（自然语言）</td>
</tr>
<tr>
<td>Authorization</td>
<td>Web认证信息</td>
</tr>
<tr>
<td>Expect</td>
<td>期待服务器的特定行为</td>
</tr>
<tr>
<td>From</td>
<td>用户的电子邮箱地址</td>
</tr>
<tr>
<td>Host</td>
<td>请求资源所在服务器</td>
</tr>
<tr>
<td>If-Match</td>
<td>比较实体标记（ETag）</td>
</tr>
<tr>
<td>If-Modified-Since</td>
<td>比较资源的更新时间</td>
</tr>
<tr>
<td>If-None-Match</td>
<td>比较实体标记（与 If-Match 相反）</td>
</tr>
<tr>
<td>If-Range</td>
<td>资源未更新时发送实体 Byte 的范围请求</td>
</tr>
<tr>
<td>If-Unmodified-Since</td>
<td>比较资源的更新时间（与If-Modified-Since相反）</td>
</tr>
<tr>
<td>Max-Forwards</td>
<td>最大传输逐跳数</td>
</tr>
<tr>
<td>Proxy-Authorization</td>
<td>代理服务器要求客户端的认证信息</td>
</tr>
<tr>
<td>Range</td>
<td>实体的字节范围请求</td>
</tr>
<tr>
<td>Referer</td>
<td>对请求中 URI 的原始获取方</td>
</tr>
<tr>
<td>TE</td>
<td>传输编码的优先级</td>
</tr>
<tr>
<td>User-Agent</td>
<td>HTTP 客户端程序的信息</td>
</tr>
</tbody></table>
</li>
</ol>
<ol start="3">
<li><p>响应首部字段</p>
<table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Accept-Ranges</td>
<td>是否接受字节范围请求</td>
</tr>
<tr>
<td>Age</td>
<td>推算资源创建经过时间</td>
</tr>
<tr>
<td>ETag</td>
<td>资源的匹配信息</td>
</tr>
<tr>
<td>Location</td>
<td>令客户端重定向至指定URI</td>
</tr>
<tr>
<td>Proxy-Authenticate</td>
<td>代理服务器对客户端的认证信息</td>
</tr>
<tr>
<td>Retry-After</td>
<td>对再次发起请求的时机要求</td>
</tr>
<tr>
<td>Server</td>
<td>HTTP服务器的安装信息</td>
</tr>
<tr>
<td>Vary</td>
<td>代理服务器缓存的管理信息</td>
</tr>
<tr>
<td>WWW-Authenticate</td>
<td>服务器对客户端的认证信息</td>
</tr>
<tr>
<td>4. 实体首部字段</td>
<td></td>
</tr>
</tbody></table>
<p>   <img src="assets/1553841420781.png" alt="实体首部字段"></p>
<ol start="5">
<li>cookie</li>
</ol>
</li>
</ol>
<h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>常用端口：443</p>
<ul>
<li><p>HTTP+ 加密 + 认证 + 完整性保护 =HTTPS </p>
<p><img src="assets/1553885477520.png" alt="1553885477520"></p>
</li>
<li><p>https采用共享密钥和公钥加密（处理慢，安全性高）两者并用的混合加密机制</p>
<ol>
<li>使用公钥加密交换共享密钥</li>
<li>使用共享密钥进行通信</li>
</ol>
</li>
</ul>
<h2 id="HTTP追加协议"><a href="#HTTP追加协议" class="headerlink" title="HTTP追加协议"></a>HTTP追加协议</h2><h3 id="解决HTTP性能瓶颈"><a href="#解决HTTP性能瓶颈" class="headerlink" title="解决HTTP性能瓶颈"></a>解决HTTP性能瓶颈</h3><ul>
<li><p>Ajax——局部更新</p>
</li>
<li><p>Comet——保留响应</p>
<ul>
<li><p>SPYD</p>
<blockquote>
<p>SPDY 没有完全改写 HTTP 协议，而是在 TCP/IP 的应用层与运输层之 间通过新加会话层的形式运作。同时，考虑到安全性问题，SPDY 规 定通信中使用 SSL。 </p>
</blockquote>
<p><img src="assets/1553889339542.png" alt="1553889339542"></p>
</li>
<li><p>WebSocket</p>
<blockquote>
<p>一旦 Web 服务器与客户端之间建立起 WebSocket 协议的通信连接， 之后所有的通信都依靠这个专用协议进行。通信过程中可互相发送 JSON、XML、HTML 或图片等任意格式的数据。 由于是建立在 HTTP 基础上的协议，因此<strong>连接的发起方仍是客户端， 而一旦确立 WebSocket 通信连接，不论服务器还是客户端，任意一方 都可直接向对方发送报文</strong>。</p>
<p>为了实现 WebSocket 通信，需要用到 HTTP 的 Upgrade 首部字 段，告知服务器通信协议发生改变，以达到握手的目的</p>
</blockquote>
<p>特点</p>
<ol>
<li>推送功能 ……服务器-&gt;客户端</li>
<li>减少通信量  ……保持连接状态，首部信息较少</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="Web攻击"><a href="#Web攻击" class="headerlink" title="Web攻击"></a>Web攻击</h2><ul>
<li><p>Web 应用端（服务器端）的验证</p>
</li>
<li><p>跨站脚本攻击 </p>
</li>
<li><p>对用户 Cookie 的窃取攻击</p>
</li>
<li><p>SQL 注入攻击 </p>
</li>
<li><p>OS 命令注入攻击 </p>
</li>
<li><p>目录遍历攻击 </p>
</li>
<li><p>远程文件包含漏洞 </p>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>思维导图</p>
<p><img src="assets/1553905547631.png" alt="1553905547631"></p>
<ul>
<li><p>用单台虚拟主机实现多个域名</p>
<blockquote>
<p>提 供 Web 托管服务（Web Hosting Service）的供应商，可以用一台服务 器为多位客户服务，也可以以每位客户持有的域名运行各自不同的网 站。这是因为利用了虚拟主机（Virtual Host，又称虚拟服务器）的功 能。</p>
</blockquote>
<p>位于同一台服务器上的web服务器经过域名转换后，IP地址相同。因此在发送HTTP请求的时候，必须在host首部内完整指出主机名或域名的URI。</p>
</li>
<li><input checked="" disabled="" type="checkbox"> <p>客户端如何知道web服务通过虚拟主机？</p>
</li>
<li><p>在host首部字段说明完整的域名，通过域名来区分同一服务器上的虚拟主机</p>
</li>
<li><input checked="" disabled="" type="checkbox"> <p>URL和URI的区别</p>
</li>
</ul>
<blockquote>
<p>URL：(Uniform/Universal Resource Locator 的缩写，统一资源定位符) </p>
<p>URI：(Uniform Resource Identifier 的缩写，统一资源标识符)（代表一种标准）。 </p>
</blockquote>
<p>URI 属于 URL 更高层次的抽象，一种字符串文本标准。 </p>
<p>URL是一种具体的URI，它是URI的一个子集，它不仅唯一标识资源，而且还提供了定位该资源的信息。URI 是一种语义上的抽象概念，可以是绝对的，也可以是相对的，而URL则必须提供足够的信息来定位，是绝对的。 </p>
<ul>
<li><input checked="" disabled="" type="checkbox"> GET和POST的区别</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>GET</th>
<th>POST</th>
</tr>
</thead>
<tbody><tr>
<td>回退时</td>
<td>无害</td>
<td>再次请求</td>
</tr>
<tr>
<td>cache</td>
<td>会</td>
<td>需要手动设置</td>
</tr>
<tr>
<td>编码</td>
<td>URL</td>
<td>多种编码</td>
</tr>
<tr>
<td>浏览器历史记录</td>
<td>保留</td>
<td>不保留</td>
</tr>
<tr>
<td>长度限制</td>
<td>受浏览器限制</td>
<td>无</td>
</tr>
<tr>
<td>参数数据类型</td>
<td>ASCII</td>
<td>任意</td>
</tr>
<tr>
<td>传递方式</td>
<td>URL</td>
<td>request body</td>
</tr>
<tr>
<td><strong>传输数据包</strong></td>
<td>1个</td>
<td>2个</td>
</tr>
</tbody></table>
<ul>
<li><p><strong>两者本质上都是采用TCP协议进行传输，因此在传输过程中没有差异</strong></p>
</li>
<li><input checked="" disabled="" type="checkbox"> <p>幂等请求 </p>
</li>
</ul>
<blockquote>
<p><strong>HTTP幂等方法，是指无论调用这个url多少次，都不会有不同的结果的HTTP方法。</strong> </p>
</blockquote>
<p>HTTP GET方法用于获取资源，不应有副作用，所以是幂等的。 GET请求可能会每次得到<strong>不同的结果</strong>，但它本身并<strong>没有产生任何副作用</strong>，因而是满足幂等性的。 </p>
<p><em>调用多次的结果和调用一次的结果一致，如DELETE调用一次删除指定资源，再次调用无论该资源是否存在，依然删除该资源。因此其是幂等</em></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="yezh"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">yezh</p>
  <div class="site-description" itemprop="description">what's you problem</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">41</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">50</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zdzh" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zdzh" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yezh</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.7.2
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
